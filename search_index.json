[["index.html", "RiboProfiler Reference Book Chapter 1 About", " RiboProfiler Reference Book Jun Zhang 2023-05-22 Chapter 1 About Ribo-Seq, short for Ribosome profiling sequencing, is a high-throughput sequencing technology used to study the protein composition and translational efficiency of transcripts in cells. This technique utilizes chemical or biological methods to covalently link ribosomes with the mRNA they are translating at the moment of translation, allowing for only the mRNA bound to ribosomes to be sequenced. This enables the quantitative analysis of the translation levels and positions of each transcript. There are some tools available for analyzing Ribo-seq sequencing data, which focus on either upstream data processing or downstream data visualization. However, these tools often require users to write shell commands in a Unix system to process raw data and then switch to another IDE to visualize the processed data, which can be quite inconvenient. For R users, it is more convenient to perform all the necessary tasks within the same environment. Using R functions such as system or system2 allows you to execute shell commands in R, enabling you to call Linux software directly from R. However, it is important to note that many bioinformatics software programs cannot run on Windows. If you’re using Windows, an alternative option is to use a Windows version of the software built using MinGW tools. Additionally, there are several R-based software programs available to complete the upstream steps, such as Rbowtie2, Rhisat2, and Rsubread. RiboProfiler integrates the upstream raw data analysis and downstream data visualization. All the steps can be done in R environment. You can also analysis the common ribo-seq and SeRP-seq(Selective ribosome profiling). Citation: Jun Zhang (2023). RiboProfiler: Integrating Ribo-SEQ Upstream and Downstream Analysis. https://github.com/junjunlab/RiboProfiler Make sure you have isntalled julia and python. You can install the development version of RiboProfiler: # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;junjunlab/RiboProfiler&quot;) # or remotes::install_github(&quot;junjunlab/RiboProfiler&quot;) library(RiboProfiler) "],["workflow.html", "Chapter 2 Workflow", " Chapter 2 Workflow RiboProfiler has two main mapping strategies: genome-based and transcriptome-based. Since mature RNA is typically bound by ribosomes for translation into protein, I recommend aligning reads to the transcriptome. If you choose to align reads to the genome instead, you can transform the resulting alignment positions to transcriptomic positions using the gene annotation file (GTF). For transcriptome-based mapping, we select the longest CDS transcript as input. If multiple transcripts have the same CDS length, we choose the one with the longest exon length. For paired end sequencing, just use one of them to perform the analysis such as read1. Here’s a simplified flowchart to illustrate the process: "],["align-on-genome.html", "Chapter 3 Align on genome 3.1 Check papers data processing 3.2 Trim adaptors 3.3 Build index 3.4 Check index files 3.5 Remove rRNA and tRNA contamination 3.6 Map to genome 3.7 Sam to bam 3.8 Ribo-seq QC check 3.9 3.10 Calculate Ribo density and RNA coverage 3.11 Coordinate transformation 3.12 Track plot 3.13 Quantification", " Chapter 3 Align on genome This chapter we will describe the total ribo-seq workflow with aligning reads on genome. The test dataset is from GSE157519(Adaptive translational pausing is a hallmark of the cellular response to severe environmental stress). You can download raw fastq files to follow this analysis flow. 3.1 Check papers data processing The RNA-seq data was generated using paired-end sequencing, while the Ribo-seq data was generated using single-end sequencing. For convenience, we used the read1 of the RNA-seq data as input for our analysis. The follows are details of paper’s data processing: 3.2 Trim adaptors Here are the raw fastq files: library(RiboProfiler) # ┌────────────────────────────────────────────────────────────────┐ # │ │ # │ Welcome to use RiboProfiler package for Ribo-seq analysis. │ # │ │ # └────────────────────────────────────────────────────────────────┘ # # The version of RiboProfiler: 0.0.5 # Any advice or suggestions please contact with me: 3219030654@stu.cpu.edu.cn. list.files(&quot;1.raw-data/&quot;,&quot;*.gz&quot;) # [1] &quot;SRR12594201.fastq.gz&quot; &quot;SRR12594205.fastq.gz&quot; &quot;SRR12594209.fastq.gz&quot; # [4] &quot;SRR12594210.fastq.gz&quot; &quot;SRR12594214.fastq.gz&quot; &quot;SRR12594218.fastq.gz&quot; # [7] &quot;SRR12594219_1.fastq.gz&quot; &quot;SRR12594223_1.fastq.gz&quot; &quot;SRR12594227_1.fastq.gz&quot; # [10] &quot;SRR12594228_1.fastq.gz&quot; &quot;SRR12594232_1.fastq.gz&quot; &quot;SRR12594236_1.fastq.gz&quot; First we trim the adapters for Ribo-seq using batch_adpator_remove function: dir.create(&quot;2.trim-data&quot;) # test function fq &lt;- list.files(path = &quot;1.raw-data/&quot;,pattern = &quot;.gz&quot;,full.names = T) rmd1 &lt;- batch_adpator_remove(fastq_file1 = fq[1:6], output_dir = &quot;2.trim-data/&quot;, output_name = paste(&quot;tmp_&quot;,sapply(strsplit(fq[1:6],split = &quot;\\\\.|/&quot;), &quot;[&quot;,3), sep = &quot;&quot;), fastp_params = list(minReadLength = 15, adapterSequenceRead1 = &quot;CTGTAGGCACCATCAAT&quot;, thread = 24)) # ▶ tmp_SRR12594201 has been processed! # ▶ tmp_SRR12594205 has been processed! # ▶ tmp_SRR12594209 has been processed! # ▶ tmp_SRR12594210 has been processed! # ▶ tmp_SRR12594214 has been processed! # ▶ tmp_SRR12594218 has been processed! Then we trim the left and right bases for remaing reads: # trim bases form left and right rmd2 &lt;- batch_adpator_remove(fastq_file1 = list.files(&quot;2.trim-data/&quot;,pattern = &quot;.gz&quot;, full.names = T), output_dir = &quot;2.trim-data/&quot;, output_name = sapply(strsplit(fq[1:6],split = &quot;\\\\.|/&quot;), &quot;[&quot;,3), fastp_params = list(trimFrontRead1 = 6, trimTailRead1 = 4, adapterTrimming = FALSE, thread = 16)) # ▶ SRR12594201 has been processed! # ▶ SRR12594205 has been processed! # ▶ SRR12594209 has been processed! # ▶ SRR12594210 has been processed! # ▶ SRR12594214 has been processed! # ▶ SRR12594218 has been processed! # remove tmp file.remove(list.files(&quot;2.trim-data/&quot;,pattern = &quot;^tmp&quot;,full.names = T)) Finally we trim adapters for RNA-seq: # ============================================================================== # trim rna adapters # ============================================================================== rmd3 &lt;- batch_adpator_remove(fastq_file1 = fq[7:12], output_dir = &quot;2.trim-data/&quot;, output_name = sapply(strsplit(fq[7:12],split = &quot;\\\\.|/&quot;), &quot;[&quot;,3), fastp_params = list(minReadLength = 15, trimFrontRead1 = 1, adapterSequenceRead1 = &quot;AGATCGGAAGAG&quot;, trimTailRead1 = 90, thread = 16)) # ▶ SRR12594219_1 has been processed! # ▶ SRR12594223_1 has been processed! # ▶ SRR12594227_1 has been processed! # ▶ SRR12594228_1 has been processed! # ▶ SRR12594232_1 has been processed! # ▶ SRR12594236_1 has been processed! 3.3 Build index 3.3.1 Build index for tRNA and rRNA fetch_trRNA_from_NCBI function can download rRNA and tRNA sequences from NCBI, just supplying with your own species: # download mouse rRNA and tRNA fetch_trRNA_from_NCBI(species = &quot;Mus musculus&quot;) # ┌──────────────────────────────────────────────────────────────┐ # │ │ # │ Download tRNA and rRNA sequences from NCBI has finished! │ # │ │ # └──────────────────────────────────────────────────────────────┘ # ▶ Here are some common species Latin names: # # 人类(Homo sapiens), 大鼠(Rattus norvegicus), 小鼠(Mus musculus), # 斑马鱼(Danio rerio), 红毛猩猩(Pan troglodytes), 家犬(Canis familiaris), # 草履虫(Dictyostelium discoideum), 猴子(Macaca mulatta), 红松鼠(Tamiasciurus hudsonicus), # 家兔(Oryctolagus cuniculus), 黄鼠狼(Cricetulus griseus), 南方豹猫(Prionailurus rubiginosus), # 畜牛(Bos taurus), 绿猴(Chlorocebus sabaeus), 绵羊(Ovis aries), # 猪(Sus scrofa), 验血鸟(Taeniopygia guttata), 萨摩耶犬(Canis lupus familiaris), # 膜骨鱼(Takifugu rubripes), 猫(Felis catus), 银狐(Vulpes vulpes), # 水稻(Oryza sativa), 吸血蝙蝠(Desmodus rotundus), 巴西三带蚊(Aedes aegypti), # 印度大象(Elephas maximus), 狼(Canis lupus), 仓鼠(Cricetulus griseus), # 刺参(Strongylocentrotus purpuratus), 山羊(Capra hircus), 兔子(Oryctolagus cuniculus), # 黄猴(Macaca fascicularis), 石斑鱼(Epinephelus coioides), 柴犬(Canis lupus familiaris), # 蚯蚓(Eisenia fetida), 小萤火虫(Luciola cruciata), 白化病毒(White spot syndrome virus), # 河北地蜂(Apis cerana), 喜马拉雅兔(Ochotona curzoniae), 裸鼠(Heterocephalus glaber), # 马(Equus caballus), 胡萝卜野生种(Daucus carota subsp. carota), 水牛(Bubalus bubalis), # 歌鸲(Erithacus rubecula), 美国黑熊(Ursus americanus), 鲨鱼(Callorhinchus milii), # 大黄蜂(Vespa mandarinia), 蜡螟(Galleria mellonella), 黄斑蝶(Papilio xuthus), # 皇家企鹅(Aptenodytes forsteri), 银河野猪(Sus scrofa) We can check the sequence: system(&quot;head Mus_musculus_trRNA.fa&quot;) # &gt;NR_003278.3 Mus musculus 18S ribosomal RNA (Rn18s), ribosomal RNA # ACCTGGTTGATCCTGCCAGGTAGCATATGCTTGTCTCAAAGATTAAGCCATGCATGTCTAAGTACGCACGGCCGGTACAG # TGAAACTGCGAATGGCTCATTAAATCAGTTATGGTTCCTTTGGTCGCTCGCTCCTCTCCTACTTGGATAACTGTGGTAAT # TCTAGAGCTAATACATGCCGACGGGCGCTGACCCCCCTTCCCGGGGGGGGATGCGTGCATTTATCAGATCAAAACCAACC # CGGTGAGCTCCCTCCCGGCTCCGGCCGGGGGTCGGGCGCCGGCGGCTTGGTGACTCTAGATAACCTCGGGCCGATCGCAC # GCCCCCCGTGGCGGCGACGACCCATTCGAACGTCTGCCCTATCAACTTTCGATGGTAGTCGCCGTGCCTACCATGGTGAC # CACGGGTGACGGGGAATCAGGGTTCGATTCCGGAGAGGGAGCCTGAGAAACGGCTACCACATCCAAGGAAGGCAGCAGGC # GCGCAAATTACCCACTCCCGACCCGGGGAGGTAGTGACGAAAAATAACAATACAGGACTCTTTCGAGGCCCTGTAATTGG # AATGAGTCCACTTTAAATCCTTTAACGAGGATCCATTGGAGGGCAAGTCTGGTGCCAGCAGCCGCGGTAATTCCAGCTCC # AATAGCGTATATTAAAGTTGCTGCAGTTAAAAAGCTCGTAGTTGGATCTTGGGAGCGGGCGGGCGGTCCGCCGCGAGGCG # [1] 0 trRNA_index_build is used to build index based on bowtie2 software: # buid index for tRNA and tRNA trRNA_index_build(trRNA_file = &quot;Mus_musculus_trRNA.fa&quot;, prefix = &quot;GRCm38_trRNA&quot;) # ┌────────────────────────────────────────────────────┐ # │ │ # │ Building index for tRNA and rRNA has finished! │ # │ │ # └────────────────────────────────────────────────────┘ 3.3.2 Build index for genome Genome sequence can be downloaded from some database like ensembl, UCSC, gencode. Here we use mouse GRCm38 genome sequence from ensembl. reference_index_build is used to build index based on Rhisat2 software: reference_index_build(reference_file = &quot;Mus_musculus.GRCm38.dna.primary_assembly.fa&quot;, prefix = &quot;GRCm38_ref&quot;, threads = 8) # ┌────────────────────────────────────────────────────┐ # │ │ # │ Building index for reference has finished! │ # │ │ # └────────────────────────────────────────────────────┘ 3.4 Check index files The index files have been save in 0.index-data/ directory: list.files(&quot;0.index-data/&quot;,recursive = T) # [1] &quot;ref-index/GRCm38_ref.1.ht2&quot; &quot;ref-index/GRCm38_ref.2.ht2&quot; # [3] &quot;ref-index/GRCm38_ref.3.ht2&quot; &quot;ref-index/GRCm38_ref.4.ht2&quot; # [5] &quot;ref-index/GRCm38_ref.5.ht2&quot; &quot;ref-index/GRCm38_ref.6.ht2&quot; # [7] &quot;ref-index/GRCm38_ref.7.ht2&quot; &quot;ref-index/GRCm38_ref.8.ht2&quot; # [9] &quot;rtRNA-index/GRCm38_trRNA.1.bt2&quot; &quot;rtRNA-index/GRCm38_trRNA.2.bt2&quot; # [11] &quot;rtRNA-index/GRCm38_trRNA.3.bt2&quot; &quot;rtRNA-index/GRCm38_trRNA.4.bt2&quot; # [13] &quot;rtRNA-index/GRCm38_trRNA.rev.1.bt2&quot; &quot;rtRNA-index/GRCm38_trRNA.rev.2.bt2&quot; 3.5 Remove rRNA and tRNA contamination The RNA content in a prokaryotic or an eukaryotic cell consists of 80–90% rRNA, 10–15% transfer RNA (tRNA) and 3–7% messenger RNA (mRNA) and regulatory ncRNA.The presence of abundant rRNA can introduce substantial bias to transcriptome data. A number of protein coding genes contain some rRNA-like sequence segments, so their expression levels can be strongly overestimated unless the rRNA reads are removed. Furthermore, rRNA removal can greatly reduce the data size for downstream analysis and accelerate the entire workflow. Here we align the reads on tRNA and rRNA sequences to remove reads which come from tRNA and rRNA. bowtie2_align will try download windows executable bowtie2 software from bowtie2. You can download it by yourself if this failed. Making sure the software is in parent directory: list.files(&quot;bowtie2-2.5.1-mingw-x86_64/&quot;,full.names = T) |&gt; head() # [1] &quot;bowtie2-2.5.1-mingw-x86_64/AUTHORS&quot; # [2] &quot;bowtie2-2.5.1-mingw-x86_64/bowtie2&quot; # [3] &quot;bowtie2-2.5.1-mingw-x86_64/bowtie2-align-l&quot; # [4] &quot;bowtie2-2.5.1-mingw-x86_64/bowtie2-align-l-debug&quot; # [5] &quot;bowtie2-2.5.1-mingw-x86_64/bowtie2-align-s&quot; # [6] &quot;bowtie2-2.5.1-mingw-x86_64/bowtie2-align-s-debug&quot; Now remove the tRNA and rRNA sequences using bowtie2: # ============================================================================== # remove trRNA sequence # ============================================================================== dir.create(&quot;3.rmtrRNA-data&quot;) # loop for remove trRNA sequence clean_fq &lt;- list.files(&quot;2.trim-data/&quot;,pattern = &quot;.fastq.gz&quot;,full.names = T) clean_fq # [1] &quot;2.trim-data/SRR12594201_R1.fastq.gz&quot; &quot;2.trim-data/SRR12594205_R1.fastq.gz&quot; # [3] &quot;2.trim-data/SRR12594209_R1.fastq.gz&quot; &quot;2.trim-data/SRR12594210_R1.fastq.gz&quot; # [5] &quot;2.trim-data/SRR12594214_R1.fastq.gz&quot; &quot;2.trim-data/SRR12594218_R1.fastq.gz&quot; # [7] &quot;2.trim-data/SRR12594219_1_R1.fastq.gz&quot; &quot;2.trim-data/SRR12594223_1_R1.fastq.gz&quot; # [9] &quot;2.trim-data/SRR12594227_1_R1.fastq.gz&quot; &quot;2.trim-data/SRR12594228_1_R1.fastq.gz&quot; # [11] &quot;2.trim-data/SRR12594232_1_R1.fastq.gz&quot; &quot;2.trim-data/SRR12594236_1_R1.fastq.gz&quot; output_sam &lt;- paste(&quot;3.rmtrRNA-data/&quot;,sapply(strsplit(clean_fq,split = &quot;\\\\.|/&quot;), &quot;[&quot;,3), &quot;.sam&quot;,sep = &quot;&quot;) output_sam # [1] &quot;3.rmtrRNA-data/SRR12594201_R1.sam&quot; &quot;3.rmtrRNA-data/SRR12594205_R1.sam&quot; # [3] &quot;3.rmtrRNA-data/SRR12594209_R1.sam&quot; &quot;3.rmtrRNA-data/SRR12594210_R1.sam&quot; # [5] &quot;3.rmtrRNA-data/SRR12594214_R1.sam&quot; &quot;3.rmtrRNA-data/SRR12594218_R1.sam&quot; # [7] &quot;3.rmtrRNA-data/SRR12594219_1_R1.sam&quot; &quot;3.rmtrRNA-data/SRR12594223_1_R1.sam&quot; # [9] &quot;3.rmtrRNA-data/SRR12594227_1_R1.sam&quot; &quot;3.rmtrRNA-data/SRR12594228_1_R1.sam&quot; # [11] &quot;3.rmtrRNA-data/SRR12594232_1_R1.sam&quot; &quot;3.rmtrRNA-data/SRR12594236_1_R1.sam&quot; rm_trRNAfq &lt;- paste(&quot;3.rmtrRNA-data/&quot;,sapply(strsplit(clean_fq,split = &quot;\\\\.|/&quot;), &quot;[&quot;,3), &quot;_rmtrRNA.fq&quot;,sep = &quot;&quot;) # [1] &quot;3.rmtrRNA-data/SRR12594201_R1_rmtrRNA.fq&quot; &quot;3.rmtrRNA-data/SRR12594205_R1_rmtrRNA.fq&quot; # [3] &quot;3.rmtrRNA-data/SRR12594209_R1_rmtrRNA.fq&quot; &quot;3.rmtrRNA-data/SRR12594210_R1_rmtrRNA.fq&quot; # [5] &quot;3.rmtrRNA-data/SRR12594214_R1_rmtrRNA.fq&quot; &quot;3.rmtrRNA-data/SRR12594218_R1_rmtrRNA.fq&quot; # [7] &quot;3.rmtrRNA-data/SRR12594219_1_R1_rmtrRNA.fq&quot; &quot;3.rmtrRNA-data/SRR12594223_1_R1_rmtrRNA.fq&quot; # [9] &quot;3.rmtrRNA-data/SRR12594227_1_R1_rmtrRNA.fq&quot; &quot;3.rmtrRNA-data/SRR12594228_1_R1_rmtrRNA.fq&quot; # [11] &quot;3.rmtrRNA-data/SRR12594232_1_R1_rmtrRNA.fq&quot; &quot;3.rmtrRNA-data/SRR12594236_1_R1_rmtrRNA.fq&quot; # batch align lapply(seq_along(clean_fq),function(x){ bowtie2_align(index = &quot;0.index-data/rtRNA-index/GRCm38_trRNA&quot;, fq_file1 = clean_fq[x], output_file = output_sam[x], threads = 24, bowtie2_params = paste(&quot;--un &quot;,rm_trRNAfq[x],sep = &quot;&quot;)) }) -&gt; tmp # ▶ 3.rmtrRNA-data/SRR12594201_R1.sam has been processed! # ▶ 3.rmtrRNA-data/SRR12594205_R1.sam has been processed! # ▶ 3.rmtrRNA-data/SRR12594209_R1.sam has been processed! # ... # remove tmp sam file.remove(list.files(&quot;3.rmtrRNA-data/&quot;,pattern = &quot;.sam$&quot;,full.names = T)) 3.5.1 mapping info visualization plot_mapinfo allows you plot the details of mapping: # plot map_info &lt;- list.files(&quot;3.rmtrRNA-data/&quot;,pattern = &quot;mapinfo.txt&quot;,full.names = TRUE) # barplot plot_mapinfo(mapinfo_file = map_info, file_name = sapply(strsplit(clean_fq,split = &quot;\\\\.|/|_&quot;), &quot;[&quot;,3)) Or plot a table: # table plot_mapinfo(mapinfo_file = map_info, file_name = sapply(strsplit(clean_fq,split = &quot;\\\\.|/|_&quot;), &quot;[&quot;,3), plot_type = &quot;table&quot;) 3.6 Map to genome batch_hisat_align uses Rhisat2 to align reads on genome: # ============================================================================== # map to genome # ============================================================================== dir.create(&quot;4.map-data&quot;) # batch map to genome fq_file1 &lt;- list.files(&quot;3.rmtrRNA-data/&quot;,pattern = &quot;.fq$&quot;,full.names = T) output_file &lt;- c(&quot;ribo_nromal_rep1&quot;,&quot;ribo_700_2h_rep1&quot;,&quot;ribo_700_2h_r2h_rep1&quot;, &quot;ribo_nromal_rep2&quot;,&quot;ribo_700_2h_rep2&quot;,&quot;ribo_700_2h_r2h_rep2&quot;, &quot;rna_nromal_rep1&quot;,&quot;rna_700_2h_rep1&quot;,&quot;rna_700_2h_r2h_rep1&quot;, &quot;rna_nromal_rep2&quot;,&quot;rna_700_2h_rep2&quot;,&quot;rna_700_2h_r2h_rep2&quot;) batch_hisat_align(index = &quot;0.index-data/ref-index/GRCm38_ref&quot;, fq_file1 = fq_file1, output_dir = &quot;4.map-data/&quot;, output_file = output_file, threads = 24,hisat2_params = list(k = 1)) # ▶ ribo_nromal_rep1 has been processed! # ▶ ribo_700_2h_rep1 has been processed! # ▶ ribo_700_2h_r2h_rep1 has been processed! # ... Plot mapinfo barplot: map_info_geome &lt;- list.files(&quot;4.map-data/&quot;,pattern = &quot;mapinfo.txt&quot;,full.names = TRUE) # barplot plot_mapinfo(mapinfo_file = map_info_geome, file_name = sapply(strsplit(map_info_geome,split = &quot;_mapinfo.txt|/&quot;), &quot;[&quot;,2)) Plot with a table: # table plot_mapinfo(mapinfo_file = map_info_geome, file_name = sapply(strsplit(map_info_geome,split = &quot;_mapinfo.txt|/&quot;), &quot;[&quot;,2), plot_type = &quot;table&quot;) 3.7 Sam to bam Covert the sam files into bam format: # ============================================================================== # sam to bam # ============================================================================== dir.create(&quot;4.map-data/bam-data&quot;,recursive = TRUE) # convert sam to bam batch_sam2bam(sam_file = paste(&quot;4.map-data/&quot;,output_file,&quot;.sam&quot;,sep = &quot;&quot;), bam_file = paste(&quot;4.map-data/bam-data/&quot;,output_file,sep = &quot;&quot;)) # [bam_sort_core] merging from 3 files and 1 in-memory blocks... # ▶ 4.map-data/ribo_nromal_rep1.sam has been processed! # [bam_sort_core] merging from 1 files and 1 in-memory blocks... # ▶ 4.map-data/ribo_700_2h_rep1.sam has been processed! # [bam_sort_core] merging from 2 files and 1 in-memory blocks... # ▶ 4.map-data/ribo_700_2h_r2h_rep1.sam has been processed! # [bam_sort_core] merging from 3 files and 1 in-memory blocks... # ... 3.8 Ribo-seq QC check 3.8.1 prepare longest transcript First we should prepare the longest transcript for each protein gene with gene annotation file: dir.create(&quot;5.analysis-data&quot;) setwd(&quot;5.analysis-data&quot;) # ============================================================================== # 1_prepare gene annotation file # ============================================================================== pre_longest_trans_info(gtf_file = &quot;../Mus_musculus.GRCm38.102.gtf.gz&quot;, out_file = &quot;longest_info.txt&quot;) # ================================ job finished. 3.8.2 prepare QC data pre_qc_data will produce QC data for ribo-seq sam files: # ============================================================================== # 2_prepare Ribo QC data # ============================================================================== sam_file = list.files(&quot;../4.map-data/&quot;,pattern = &quot;^ribo.*sam$&quot;,full.names = TRUE) sam_file # [1] &quot;../4.map-data/ribo_700_2h_r2h_rep1.sam&quot; &quot;../4.map-data/ribo_700_2h_r2h_rep2.sam&quot; # [3] &quot;../4.map-data/ribo_700_2h_rep1.sam&quot; &quot;../4.map-data/ribo_700_2h_rep2.sam&quot; # [5] &quot;../4.map-data/ribo_nromal_rep1.sam&quot; &quot;../4.map-data/ribo_nromal_rep2.sam&quot; sample_name &lt;- sapply(strsplit(list.files(&quot;../4.map-data/&quot;,pattern = &quot;^ribo.*sam$&quot;), split = &quot;.sam&quot;), &quot;[&quot;,1) sample_name # [1] &quot;ribo_700_2h_r2h_rep1&quot; &quot;ribo_700_2h_r2h_rep2&quot; &quot;ribo_700_2h_rep1&quot; # [4] &quot;ribo_700_2h_rep2&quot; &quot;ribo_nromal_rep1&quot; &quot;ribo_nromal_rep2&quot; # run pre_qc_data(longest_trans_file = &quot;longest_info.txt&quot;, sam_file = sam_file, out_file = paste(sample_name,&quot;.qc.txt&quot;,sep = &quot;&quot;), mapping_type = &quot;genome&quot;, seq_type = &quot;singleEnd&quot;) # &quot;Transforming genomic positions into transcriptome positions has been done successfully.&quot; # # &quot;Processing sam files...&quot; # # &quot;../4.map-data/ribo_700_2h_r2h_rep1.sam has been processed.&quot; # # &quot;../4.map-data/ribo_700_2h_r2h_rep2.sam has been processed.&quot; # # &quot;../4.map-data/ribo_700_2h_rep1.sam has been processed.&quot; # ... 3.8.3 load qc data load_qc_data will read all the qc data into R and return a data frame: # load qc data qc_df &lt;- load_qc_data() # QC input files: # ribo_700_2h_r2h_rep1.qc.txt # ribo_700_2h_r2h_rep2.qc.txt # ribo_700_2h_rep1.qc.txt # ribo_700_2h_rep2.qc.txt # ribo_nromal_rep1.qc.txt # ribo_nromal_rep2.qc.txt # check head(qc_df,3) # length framest relst framesp relsp feature counts sample group # 1 30 2 1988 1 -118 3 1 ribo_700_2h_r2h_rep1 NA # 2 28 1 988 2 -2060 3 1 ribo_700_2h_r2h_rep1 NA # 3 25 1 1042 2 -374 3 1 ribo_700_2h_r2h_rep1 NA qc_df$length &lt;- factor(qc_df$length) qc_df$sample &lt;- factor(qc_df$sample, levels = c(&quot;ribo_nromal_rep1&quot;,&quot;ribo_700_2h_rep1&quot;,&quot;ribo_700_2h_r2h_rep1&quot;, &quot;ribo_nromal_rep2&quot;,&quot;ribo_700_2h_rep2&quot;,&quot;ribo_700_2h_r2h_rep2&quot;) ) 3.8.4 qc visualization Now plot the qc data with multiple kinds of graph, first check the length distribution of fragments: # length distribution qc_plot(qc_data = qc_df,type = &quot;length&quot;,facet_wrap_list = list(ncol = 3)) Frames with length distribution: # length with frame qc_plot(qc_data = qc_df,type = &quot;length_frame&quot;,facet_wrap_list = list(ncol = 3)) Different region features: # region features qc_plot(qc_data = qc_df,type = &quot;feature&quot;,facet_wrap_list = list(ncol = 3)) All frames ratio: # all frames qc_plot(qc_data = qc_df,type = &quot;frame&quot;,facet_wrap_list = list(ncol = 3)) Realtive to start codon with periodicity: # relative to start/stop site 5x10 rel_to_start_stop(qc_data = qc_df,type = &quot;relst&quot;, facet_wrap_list = list(ncol = 3,scales = &quot;fixed&quot;)) You can zoom the distance: rel_to_start_stop(qc_data = qc_df,type = &quot;relst&quot;, dist_range = c(-20,60), facet_wrap_list = list(ncol = 3,scales = &quot;fixed&quot;)) Realtive to stop codon with periodicity: rel_to_start_stop(qc_data = qc_df,type = &quot;relsp&quot;, facet_wrap_list = list(ncol = 3,scales = &quot;fixed&quot;)) Here is the origin paper’s figure: 3.9 3.10 Calculate Ribo density and RNA coverage This step will produce each ribosome density and RNA coverage on genomic positions: # ============================================================================== # 3_prepare Ribo density and RNA coverage data # ============================================================================== # calculate Ribo density pre_ribo_density_data(sam_file = sam_file, out_file = paste(sample_name,&quot;.density.txt&quot;,sep = &quot;&quot;)) # ../4.map-data/ribo_700_2h_r2h_rep1.sam has been processed! # ../4.map-data/ribo_700_2h_r2h_rep2.sam has been processed! # ../4.map-data/ribo_700_2h_rep1.sam has been processed! # ../4.map-data/ribo_700_2h_rep2.sam has been processed! # ../4.map-data/ribo_nromal_rep1.sam has been processed! # ../4.map-data/ribo_nromal_rep2.sam has been processed! # NULL # calculate RNA coverage bam_file_rna = list.files(&quot;../4.map-data/bam-data/&quot;,pattern = &quot;^rna.*bam$&quot;,full.names = TRUE) bam_file_rna # [1] &quot;../4.map-data/bam-data/rna_700_2h_r2h_rep1.bam&quot; &quot;../4.map-data/bam-data/rna_700_2h_r2h_rep2.bam&quot; # [3] &quot;../4.map-data/bam-data/rna_700_2h_rep1.bam&quot; &quot;../4.map-data/bam-data/rna_700_2h_rep2.bam&quot; # [5] &quot;../4.map-data/bam-data/rna_nromal_rep1.bam&quot; &quot;../4.map-data/bam-data/rna_nromal_rep2.bam&quot; sample_name_rna &lt;- sapply(strsplit(list.files(&quot;../4.map-data/bam-data/&quot;,pattern = &quot;^rna.*bam$&quot;), split = &quot;.bam&quot;), &quot;[&quot;,1) sample_name_rna # [1] &quot;rna_700_2h_r2h_rep1&quot; &quot;rna_700_2h_r2h_rep2&quot; &quot;rna_700_2h_rep1&quot; &quot;rna_700_2h_rep2&quot; # [5] &quot;rna_nromal_rep1&quot; &quot;rna_nromal_rep2&quot; pre_rna_coverage_data(bam_file = bam_file_rna, out_file = paste(sample_name_rna,&quot;.coverage.txt&quot;,sep = &quot;&quot;)) # ../4.map-data/bam-data/rna_700_2h_r2h_rep1.bam has been processed! # ../4.map-data/bam-data/rna_700_2h_r2h_rep2.bam has been processed! # ../4.map-data/bam-data/rna_700_2h_rep1.bam has been processed! # ../4.map-data/bam-data/rna_700_2h_rep2.bam has been processed! # ../4.map-data/bam-data/rna_nromal_rep1.bam has been processed! # ../4.map-data/bam-data/rna_nromal_rep2.bam has been processed! 3.11 Coordinate transformation Now we need to transform the genomic coordinates into transcriptomic coordinates according to the longest transcript file prepared before: # ============================================================================== # 4_transform genomic coordinate into transcriotomic coordinate # ============================================================================== pre_gene_trans_density(gene_anno = &quot;longest_info.txt&quot;, density_file = c(paste(sample_name,&quot;.density.txt&quot;,sep = &quot;&quot;), paste(sample_name_rna,&quot;.coverage.txt&quot;,sep = &quot;&quot;)), out_file = c(paste(sample_name,&quot;.trans.txt&quot;,sep = &quot;&quot;), paste(sample_name_rna,&quot;.trans.txt&quot;,sep = &quot;&quot;))) # 2.density-data/ribo_700_2h_r2h_rep1.density.txt has been processed! # 2.density-data/ribo_700_2h_r2h_rep2.density.txt has been processed! # ... 3.12 Track plot Once if we have ribo density and RNA coverage files, we can use load_track_data to load the data and track_plot to visualize data: 3.12.1 load track data # ============================================================================== # 5_load denisty and coverage data for specific gene # ============================================================================== track_df &lt;- load_track_data(ribo_file = paste(sample_name,&quot;.trans.txt&quot;,sep = &quot;&quot;), rna_file = paste(sample_name_rna,&quot;.trans.txt&quot;,sep = &quot;&quot;), sample_name = paste(rep(c(&quot;700_2h_r2h&quot;,&quot;700_2h&quot;,&quot;normal&quot;),each = 2), c(&quot;_rep1&quot;,&quot;_rep2&quot;),sep = &quot;&quot;), gene_list = c(&quot;Ndufb3&quot;,&quot;Ndufb6&quot;,&quot;Rps7&quot;,&quot;Uqcrfs1&quot;,&quot;Ndufv1&quot;,&quot;Sat1&quot;)) # check head(track_df,3) # gene_name trans_id transpos density type sample # 1 Ndufb3 ENSMUST00000027193 1 0 ribo 700_2h_r2h # 2 Ndufb3 ENSMUST00000027193 2 0 ribo 700_2h_r2h # 3 Ndufb3 ENSMUST00000027193 3 0 ribo 700_2h_r2h 3.12.2 plot tracks # 6x12 track_plot(signal_data = track_df, gene_anno = &quot;longest_info.txt&quot;, sample_order = c(&quot;normal_rep1&quot;,&quot;normal_rep2&quot;,&quot;700_2h_rep1&quot;,&quot;700_2h_rep2&quot;, &quot;700_2h_r2h_rep1&quot;,&quot;700_2h_r2h_rep2&quot;), remove_trans_panel_border = T, range_pos = c(0.75,0.1)) You can not reverse the RNA coverage track: track_plot(signal_data = track_df, gene_anno = &quot;longest_info.txt&quot;, sample_order = c(&quot;normal_rep1&quot;,&quot;normal_rep2&quot;,&quot;700_2h_rep1&quot;,&quot;700_2h_rep2&quot;, &quot;700_2h_r2h_rep1&quot;,&quot;700_2h_r2h_rep2&quot;), remove_trans_panel_border = T, reverse_rna = F, signal_col = c(&quot;ribo&quot; = &quot;red&quot;,&quot;rna&quot; = &quot;grey80&quot;)) Sometimes the range of RNA coverage is much than ribo density, you can use rna_signal_scale the rescale the RNA coverage range: track_plot(signal_data = track_df, gene_anno = &quot;longest_info.txt&quot;, sample_order = c(&quot;normal_rep1&quot;,&quot;normal_rep2&quot;,&quot;700_2h_rep1&quot;,&quot;700_2h_rep2&quot;, &quot;700_2h_r2h_rep1&quot;,&quot;700_2h_r2h_rep2&quot;), remove_trans_panel_border = T, reverse_rna = F, signal_col = c(&quot;ribo&quot; = &quot;red&quot;,&quot;rna&quot; = &quot;grey80&quot;), rna_signal_scale = 0.1) The reversed RNA track with rescaled coverage: track_plot(signal_data = track_df, gene_anno = &quot;longest_info.txt&quot;, sample_order = c(&quot;normal_rep1&quot;,&quot;normal_rep2&quot;,&quot;700_2h_rep1&quot;,&quot;700_2h_rep2&quot;, &quot;700_2h_r2h_rep1&quot;,&quot;700_2h_r2h_rep2&quot;), remove_trans_panel_border = T, signal_col = c(&quot;ribo&quot; = &quot;red&quot;,&quot;rna&quot; = &quot;grey80&quot;), rna_signal_scale = 0.1) show_ribo_only can be setted to show only ribo tracks: track_plot(signal_data = track_df, gene_anno = &quot;longest_info.txt&quot;, sample_order = c(&quot;normal_rep1&quot;,&quot;normal_rep2&quot;,&quot;700_2h_rep1&quot;,&quot;700_2h_rep2&quot;, &quot;700_2h_r2h_rep1&quot;,&quot;700_2h_r2h_rep2&quot;), remove_trans_panel_border = T, show_ribo_only = T) 3.13 Quantification You can use Rsubread featureCounts function to get count matrix: library(Rsubread) exp &lt;- featureCounts(files = list.files(&quot;../4.map-data/bam-data/&quot;,pattern = &quot;.bam$&quot;,full.names = T), annot.ext = &quot;../Mus_musculus.GRCm38.102.gtf.gz&quot;, isGTFAnnotationFile = T, GTF.featureType = &quot;exon&quot;, GTF.attrType = &quot;gene_id&quot;, GTF.attrType.extra = c(&quot;gene_name&quot;,&quot;gene_biotype&quot;), isPairedEnd = FALSE, nthreads = 12) counts &lt;- exp$counts head(counts[1:3,1:3]) # ribo_700_2h_r2h_rep1.bam ribo_700_2h_r2h_rep2.bam ribo_700_2h_rep1.bam # ENSMUSG00000102693 0 0 0 # ENSMUSG00000064842 0 2 0 # ENSMUSG00000051951 0 0 0 tpm &lt;- count_to_tpm(fc_obj = exp) head(tpm[1:3,1:3]) # gene_id ribo_700_2h_r2h_rep1.bam ribo_700_2h_r2h_rep2.bam # 1 ENSMUSG00000000001 35.70944 35.37493 # 2 ENSMUSG00000000003 0.00000 0.00000 # 3 ENSMUSG00000000028 11.93136 11.52324 You can do other related analysis with other tools based on these matrix data. "],["align-on-transcriptome.html", "Chapter 4 Align on transcriptome 4.1 Extract longest transcript sequence 4.2 Build index for transcriptome 4.3 Remove rRNA and tRNA contamination 4.4 Map to transcriptome 4.5 Sam to bam 4.6 Ribo-seq QC check 4.7 4.8 Calculate Ribo density and RNA coverage 4.9 Track plot 4.10 Metagene plot 4.11 Quantification", " Chapter 4 Align on transcriptome This chapter we will describe the total ribo-seq workflow with aligning reads on transcriptome. The test dataset is also same with GSE157519(Adaptive translational pausing is a hallmark of the cellular response to severe environmental stress). Here we directly use the clean fastq files with removed rRNA and tRNA in the former chapter. 4.1 Extract longest transcript sequence We need to extract the longest transcript sequence and index for them: # ============================================================================== # extract longest transcript fasta # ============================================================================== library(BioSeqUtils) library(dplyr) # make object mytest &lt;- loadGenomeGTF(gtfPath = &quot;Mus_musculus.GRCm38.102.gtf.gz&quot;,filterProtein = T) # all gene gene &lt;- unique(mytest@gtf$gene_name) # get transcript info rt &lt;- getTransInfo(object = mytest,geneName = gene, selecType = &quot;lcds&quot;,topN = 1) # add id rt &lt;- rt %&gt;% mutate(seq_id = paste(gene_name,gene_id,transcript_id, `5UTR` + 1,`5UTR` + CDS,exon,sep = &quot;|&quot;)) # using python code system.time(pyExtractSeq(gtf_file = &quot;Mus_musculus.GRCm38.102.gtf.gz&quot;, genome_file = &quot;Mus_musculus.GRCm38.dna.primary_assembly.fa&quot;, transcript_id = rt$transcript_id, new_id = rt$seq_id, type = &quot;exon&quot;, out_file = &quot;GRCm38_longest_transcript.fasta&quot;)) # check system(&quot;head GRCm38_longest_transcript.fasta&quot;) # &gt;0610009B22Rik|ENSMUSG00000007777|ENSMUST00000109098|209|628|892 # GCAGCCTTGCTCAGAGACGCATGTGCGCATGCCCGGTCGACTGAGCTGCCCTGATCCAAGATGGCGGCCGGACCGGGGCT # GGGGACGGGCTTAGCGCGTTACTGAGCATGCTCAGTCTTCCGTCACTTGCGTCAGGTCGGCAGCCGGCGCAGGCCGCTCA # GTCCTTCCCGGAGAGGCGGGAACATGAGCCACATATAGACAGAAGACAATGTCTGGGAGCTTCTACTTCGTAATTGTTGG # CCACCATGATAATCCGGTTTTTGAAATGGAATTTTTGCCAGCTGGGAAAGCAGAATCTAAAGATGAACACCGTCATCTGA # ACCAGTTCATAGCTCATGCTGCTCTGGACCTCGTCGACGAAAACATGTGGCTCTCCAACAACATGTACTTAAAAACTGTG # GACAAATTCAATGAGTGGTTCGTCTCGGCGTTCGTCACGGCTGGGCACATGCGGCTCATCATGCTGCATGACGTGAGGCA # CGAGGATGGCATCAAGAACTTCTTCACTGACGTCTACGACTTATACATCAAATTTGCCATGAATCCCTTTTATGAACCCA # ATTCTCCTATTCGATCGAGTGCATTCGAAAGAAAAGTTCAGTTTCTTGGGAAGAAACATCTTTTAAACTAAATGCAGAAA # AACTTCAGAATCACAGTGGGGTGTGCTCAGCAGTGGATGTATTGTAAATTACTTGATAAAGTAGCCTAGCAAACTCTTTA # [1] 0 4.2 Build index for transcriptome Then we buid index for the longest transcript fasta: # ============================================================================== # build index # ============================================================================== reference_index_build(reference_file = &quot;GRCm38_longest_transcript.fasta&quot;, prefix = &quot;GRCm38_ref&quot;, threads = 24) # ┌────────────────────────────────────────────────┐ # │ │ # │ Building index for reference has finished! │ # │ │ # └────────────────────────────────────────────────┘ 4.3 Remove rRNA and tRNA contamination Because we have done this before in mapping on genome chapter, so we skip this step. 4.4 Map to transcriptome # ============================================================================== # map to genome # ============================================================================== dir.create(&quot;4.map-data&quot;) # batch map to genome fq_file1 &lt;- list.files(&quot;../1.mapping_to_genome/3.rmtrRNA-data/&quot;,pattern = &quot;.fq&quot;,full.names = T) output_file &lt;- output_file &lt;- c(&quot;ribo_nromal_rep1&quot;,&quot;ribo_700_2h_rep1&quot;,&quot;ribo_700_2h_r2h_rep1&quot;, &quot;ribo_nromal_rep2&quot;,&quot;ribo_700_2h_rep2&quot;,&quot;ribo_700_2h_r2h_rep2&quot;, &quot;rna_nromal_rep1&quot;,&quot;rna_700_2h_rep1&quot;,&quot;rna_700_2h_r2h_rep1&quot;, &quot;rna_nromal_rep2&quot;,&quot;rna_700_2h_rep2&quot;,&quot;rna_700_2h_r2h_rep2&quot;) batch_hisat_align(index = &quot;0.index-data/ref-index/GRCm38_ref&quot;, fq_file1 = fq_file1, output_dir = &quot;4.map-data/&quot;, output_file = output_file, threads = 24,hisat2_params = list(k = 1)) # ▶ ribo_nromal_rep1 has been processed! # ▶ ribo_700_2h_rep1 has been processed! # ▶ ribo_700_2h_r2h_rep1 has been processed! # ▶ ribo_nromal_rep2 has been processed! # ▶ ribo_700_2h_rep2 has been processed! # ▶ ribo_700_2h_r2h_rep2 has been processed! # ... Plot mapinfo barplot: # plot mapping info map_info_geome &lt;- list.files(&quot;4.map-data/&quot;,pattern = &quot;mapinfo.txt&quot;,full.names = TRUE) plot_mapinfo(mapinfo_file = map_info_geome, file_name = sapply(strsplit(map_info_geome,split = &quot;_mapinfo.txt|/&quot;), &quot;[&quot;,2)) Plot with a table: plot_mapinfo(mapinfo_file = map_info_geome, file_name = sapply(strsplit(map_info_geome,split = &quot;_mapinfo.txt|/&quot;), &quot;[&quot;,2), plot_type = &quot;table&quot;) 4.5 Sam to bam Covert the sam files into bam format: # ============================================================================== # sam to bam # ============================================================================== dir.create(&quot;4.map-data/bam-data&quot;,recursive = TRUE) # convert sam to bam batch_sam2bam(sam_file = paste(&quot;4.map-data/&quot;,output_file,&quot;.sam&quot;,sep = &quot;&quot;), bam_file = paste(&quot;4.map-data/bam-data/&quot;,output_file,sep = &quot;&quot;)) # ▶ 4.map-data/rna_nromal_rep1.sam has been processed! # [bam_sort_core] merging from 12 files and 1 in-memory blocks... # ▶ 4.map-data/rna_700_2h_rep1.sam has been processed! # [bam_sort_core] merging from 17 files and 1 in-memory blocks... # ▶ 4.map-data/rna_700_2h_r2h_rep1.sam has been processed! # [bam_sort_core] merging from 21 files and 1 in-memory blocks... # ... 4.6 Ribo-seq QC check 4.6.1 prepare longest transcript First we should prepare the longest transcript for each protein gene with gene annotation file: dir.create(&quot;5.analysis-data&quot;) setwd(&quot;5.analysis-data&quot;) # ============================================================================== # 1_prepare gene annotation file # ============================================================================== pre_longest_trans_info(gtf_file = &quot;../Mus_musculus.GRCm38.102.gtf.gz&quot;, out_file = &quot;longest_info.txt&quot;) # ================================ job finished. 4.6.2 prepare QC data pre_qc_data will produce QC data for ribo-seq sam files: # ============================================================================== # 2_prepare Ribo QC data # ============================================================================== sam_file = list.files(&quot;../4.map-data/&quot;,pattern = &quot;^ribo.*sam$&quot;,full.names = TRUE) sam_file # [1] &quot;../4.map-data/ribo_700_2h_r2h_rep1.sam&quot; &quot;../4.map-data/ribo_700_2h_r2h_rep2.sam&quot; # [3] &quot;../4.map-data/ribo_700_2h_rep1.sam&quot; &quot;../4.map-data/ribo_700_2h_rep2.sam&quot; # [5] &quot;../4.map-data/ribo_nromal_rep1.sam&quot; &quot;../4.map-data/ribo_nromal_rep2.sam&quot; sample_name &lt;- sapply(strsplit(list.files(&quot;../4.map-data/&quot;,pattern = &quot;^ribo.*sam$&quot;), split = &quot;.sam&quot;), &quot;[&quot;,1) sample_name # [1] &quot;ribo_700_2h_r2h_rep1&quot; &quot;ribo_700_2h_r2h_rep2&quot; &quot;ribo_700_2h_rep1&quot; # [4] &quot;ribo_700_2h_rep2&quot; &quot;ribo_nromal_rep1&quot; &quot;ribo_nromal_rep2&quot; # run pre_qc_data(sam_file = sam_file, out_file = paste(sample_name,&quot;.qc.txt&quot;,sep = &quot;&quot;), mapping_type = &quot;transcriptome&quot;, seq_type = &quot;singleEnd&quot;) # ../4.map-data/ribo_700_2h_r2h_rep1.sam has been processed! # ../4.map-data/ribo_700_2h_r2h_rep2.sam has been processed! # ../4.map-data/ribo_700_2h_rep1.sam has been processed! # ... 4.6.3 load qc data load_qc_data will read all the qc data into R and return a data frame: # load qc data qc_df &lt;- load_qc_data() qc_df &lt;- qc_df |&gt; dplyr::filter(length &gt;= 20 &amp; length &lt;= 35) # QC input files: # ribo_700_2h_r2h_rep1.qc.txt # ribo_700_2h_r2h_rep2.qc.txt # ribo_700_2h_rep1.qc.txt # ribo_700_2h_rep2.qc.txt # ribo_nromal_rep1.qc.txt # ribo_nromal_rep2.qc.txt # check head(qc_df,3) # length framest relst framesp relsp feature counts sample group # 1 27 0 825 0 -168 3 1 ribo_700_2h_r2h_rep1 NA # 2 30 2 1916 1 -694 3 1 ribo_700_2h_r2h_rep1 NA # 3 30 0 1401 0 -21 3 7 ribo_700_2h_r2h_rep1 NA qc_df$length &lt;- factor(qc_df$length) qc_df$sample &lt;- factor(qc_df$sample, levels = c(&quot;ribo_nromal_rep1&quot;,&quot;ribo_700_2h_rep1&quot;,&quot;ribo_700_2h_r2h_rep1&quot;, &quot;ribo_nromal_rep2&quot;,&quot;ribo_700_2h_rep2&quot;,&quot;ribo_700_2h_r2h_rep2&quot;)) 4.6.4 qc visualization Now plot the qc data with multiple kinds of graph, first check the length distribution of fragments: # length distribution qc_plot(qc_data = qc_df,type = &quot;length&quot;,facet_wrap_list = list(ncol = 3)) Frames with length distribution: # length with frame qc_plot(qc_data = qc_df,type = &quot;length_frame&quot;,facet_wrap_list = list(ncol = 3)) Different region features: # region features qc_plot(qc_data = qc_df,type = &quot;feature&quot;,facet_wrap_list = list(ncol = 3)) All frames ratio: # all frames qc_plot(qc_data = qc_df,type = &quot;frame&quot;,facet_wrap_list = list(ncol = 3)) Realtive to start codon with periodicity: # relative to start/stop site 5x10 rel_to_start_stop(qc_data = qc_df,type = &quot;relst&quot;, facet_wrap_list = list(ncol = 3,scales = &quot;fixed&quot;)) Realtive to stop codon with periodicity: rel_to_start_stop(qc_data = qc_df,type = &quot;relsp&quot;, facet_wrap_list = list(ncol = 3,scales = &quot;fixed&quot;)) 4.7 4.8 Calculate Ribo density and RNA coverage # ============================================================================== # 3_prepare Ribo density and RNA coverage data # ============================================================================== # calculate Ribo density pre_ribo_density_data(sam_file = sam_file, out_file = paste(sample_name,&quot;.density.txt&quot;,sep = &quot;&quot;), mapping_type = &quot;transcriptome&quot;) # ../4.map-data/ribo_700_2h_r2h_rep1.sam has been processed! # ../4.map-data/ribo_700_2h_r2h_rep2.sam has been processed! # ../4.map-data/ribo_700_2h_rep1.sam has been processed! # ... # calculate RNA coverage bam_file_rna = list.files(&quot;../4.map-data/bam-data&quot;,pattern = &quot;^rna.*bam$&quot;,full.names = TRUE) bam_file_rna # [1] &quot;../4.map-data/bam-data/rna_700_2h_r2h_rep1.bam&quot; &quot;../4.map-data/bam-data/rna_700_2h_r2h_rep2.bam&quot; # [3] &quot;../4.map-data/bam-data/rna_700_2h_rep1.bam&quot; &quot;../4.map-data/bam-data/rna_700_2h_rep2.bam&quot; # [5] &quot;../4.map-data/bam-data/rna_nromal_rep1.bam&quot; &quot;../4.map-data/bam-data/rna_nromal_rep2.bam&quot; sample_name_rna &lt;- sapply(strsplit(list.files(&quot;../4.map-data/bam-data&quot;,pattern = &quot;^rna.*bam$&quot;), split = &quot;.bam&quot;), &quot;[&quot;,1) sample_name_rna # [1] &quot;rna_700_2h_r2h_rep1&quot; &quot;rna_700_2h_r2h_rep2&quot; &quot;rna_700_2h_rep1&quot; &quot;rna_700_2h_rep2&quot; # [5] &quot;rna_nromal_rep1&quot; &quot;rna_nromal_rep2&quot; pre_rna_coverage_data(bam_file = bam_file_rna, out_file = paste(sample_name_rna,&quot;.coverage.txt&quot;,sep = &quot;&quot;) ) # ../4.map-data/bam-data/rna_700_2h_r2h_rep1.bam has been processed! # ../4.map-data/bam-data/rna_700_2h_r2h_rep2.bam has been processed! # ../4.map-data/bam-data/rna_700_2h_rep1.bam has been processed! # ... 4.9 Track plot 4.9.1 load track data # ============================================================================== # 5_load denisty and coverage data for specific gene # ============================================================================== track_df &lt;- load_track_data(ribo_file = paste(sample_name,&quot;.density.txt&quot;,sep = &quot;&quot;), rna_file = paste(sample_name_rna,&quot;.coverage.txt&quot;,sep = &quot;&quot;), sample_name = paste(rep(c(&quot;700_2h_r2h&quot;,&quot;700_2h&quot;,&quot;normal&quot;),each = 2), c(&quot;_rep1&quot;,&quot;_rep2&quot;),sep = &quot;&quot;), gene_list = c(&quot;Ndufb3&quot;,&quot;Ndufb6&quot;,&quot;Rps7&quot;,&quot;Uqcrfs1&quot;,&quot;Ndufv1&quot;,&quot;Sat1&quot;), mapping_type = &quot;transcriptome&quot;) # check head(track_df,3) # gene_name trans_id transpos density type sample # 1 Ndufb3 ENSMUST00000027193 100 0.0528252 ribo 700_2h_r2h_rep1 # 2 Ndufb3 ENSMUST00000027193 102 0.0528252 ribo 700_2h_r2h_rep1 # 3 Ndufb3 ENSMUST00000027193 103 0.0528252 ribo 700_2h_r2h_rep1 4.9.2 plot tracks # 6x12 track_plot(signal_data = track_df |&gt; dplyr::filter(gene_name %in% c(&quot;Ndufb3&quot;,&quot;Ndufb6&quot;,&quot;Rps7&quot;)), gene_anno = &quot;longest_info.txt&quot;, sample_order = c(&quot;normal_rep1&quot;,&quot;normal_rep2&quot;,&quot;700_2h_rep1&quot;,&quot;700_2h_rep2&quot;, &quot;700_2h_r2h_rep1&quot;,&quot;700_2h_r2h_rep2&quot;), remove_trans_panel_border = T) Reverse the RNA coverage track: # reverse RNA track track_plot(signal_data = track_df |&gt; dplyr::filter(gene_name %in% c(&quot;Ndufb3&quot;,&quot;Ndufb6&quot;,&quot;Rps7&quot;)), gene_anno = &quot;longest_info.txt&quot;, sample_order = c(&quot;normal_rep1&quot;,&quot;normal_rep2&quot;,&quot;700_2h_rep1&quot;,&quot;700_2h_rep2&quot;, &quot;700_2h_r2h_rep1&quot;,&quot;700_2h_r2h_rep2&quot;), remove_trans_panel_border = T, reverse_rna = F) Another three genes: track_plot(signal_data = track_df |&gt; dplyr::filter(gene_name %in% c(&quot;Uqcrfs1&quot;,&quot;Ndufv1&quot;,&quot;Sat1&quot;)), gene_anno = &quot;longest_info.txt&quot;, sample_order = c(&quot;normal_rep1&quot;,&quot;normal_rep2&quot;,&quot;700_2h_rep1&quot;,&quot;700_2h_rep2&quot;, &quot;700_2h_r2h_rep1&quot;,&quot;700_2h_r2h_rep2&quot;), remove_trans_panel_border = T) show only ribo tracks: track_plot(signal_data = track_df |&gt; dplyr::filter(gene_name %in% c(&quot;Uqcrfs1&quot;,&quot;Ndufv1&quot;,&quot;Sat1&quot;)), gene_anno = &quot;longest_info.txt&quot;, sample_order = c(&quot;normal_rep1&quot;,&quot;normal_rep2&quot;,&quot;700_2h_rep1&quot;,&quot;700_2h_rep2&quot;, &quot;700_2h_r2h_rep1&quot;,&quot;700_2h_r2h_rep2&quot;), remove_trans_panel_border = T, show_ribo_only = T) 4.10 Metagene plot Metagene plot shows the average ribosome density relative to start/stop codon: # ============================================================================== # 7_metagene plot # ============================================================================== # prepare data pre_metagene_data(density_file = paste(sample_name[c(1,3,5)],&quot;.density.txt&quot;,sep = &quot;&quot;), out_file = paste(sample_name[c(1,3,5)],&quot;.meta.txt&quot;,sep = &quot;&quot;), mapping_type = &quot;transcriptome&quot;) # 2.density-data/ribo_700_2h_r2h_rep1.density.txt has been processed! # 2.density-data/ribo_700_2h_rep1.density.txt has been processed! # 2.density-data/ribo_nromal_rep1.density.txt has been processed! pre_metagene_data(density_file = paste(sample_name[c(1,3,5)],&quot;.density.txt&quot;,sep = &quot;&quot;), out_file = paste(sample_name[c(1,3,5)],&quot;.sp.meta.txt&quot;,sep = &quot;&quot;), mapping_type = &quot;transcriptome&quot;, mode = &quot;sp&quot;) # rel2sp pre_metagene_data(density_file = paste(sample_name[c(1,3,5)],&quot;.density.txt&quot;,sep = &quot;&quot;), out_file = paste(sample_name[c(1,3,5)],&quot;.sp.meta.txt&quot;,sep = &quot;&quot;), mapping_type = &quot;transcriptome&quot;, mode = &quot;sp&quot;) # load data meta_df &lt;- load_metagene_data() # MetaGene input files: # ribo_700_2h_r2h_rep1.meta.txt # ribo_700_2h_r2h_rep1.sp.meta.txt # ribo_700_2h_rep1.meta.txt # ribo_700_2h_rep1.sp.meta.txt # ribo_nromal_rep1.meta.txt # ribo_nromal_rep1.sp.meta.txt meta_df$group &lt;- rep(rep(c(&quot;st&quot;,&quot;sp&quot;),each = 518),3) Plot: # plot library(ggplot2) meta_df$sample &lt;- factor(meta_df$sample,levels = c(&quot;ribo_nromal_rep1&quot;,&quot;ribo_700_2h_rep1&quot;, &quot;ribo_700_2h_r2h_rep1&quot;)) ggplot(meta_df) + geom_line(aes(x = pos,y = density,color = sample),linewidth = 1) + scale_color_brewer(palette = &quot;Set1&quot;) + theme_bw() + jj_theme() + ggh4x::facet_grid2(group~sample,scales = &quot;free&quot;,independent = &quot;x&quot;) 4.11 Quantification pre_count_tpm_data will calculate genes count and tpm from sam files: # for Ribo sam_file = list.files(&quot;../4.map-data/&quot;,pattern = &quot;^ribo.*sam$&quot;,full.names = TRUE) sample_name &lt;- sapply(strsplit(list.files(&quot;../4.map-data/&quot;,pattern = &quot;^ribo.*sam$&quot;), split = &quot;.sam&quot;), &quot;[&quot;,1) # get expression matrix pre_count_tpm_data(sam_file = sam_file, out_file = paste(sample_name,&quot;.exp.txt&quot;,sep = &quot;&quot;), type = &quot;ribo&quot;) # ../4.map-data/ribo_700_2h_r2h_rep1.sam has been processed! # ../4.map-data/ribo_700_2h_r2h_rep2.sam has been processed! # ../4.map-data/ribo_700_2h_rep1.sam has been processed! # ... # for RNA sam_file = list.files(&quot;../4.map-data/&quot;,pattern = &quot;^rna.*sam$&quot;,full.names = TRUE) sample_name &lt;- sapply(strsplit(list.files(&quot;../4.map-data/&quot;,pattern = &quot;^rna.*sam$&quot;), split = &quot;.sam&quot;), &quot;[&quot;,1) # get expression matrix pre_count_tpm_data(sam_file = sam_file, out_file = paste(sample_name,&quot;.exp.txt&quot;,sep = &quot;&quot;), type = &quot;rna&quot;) # ../4.map-data/rna_700_2h_r2h_rep1.sam has been processed! # ../4.map-data/rna_700_2h_r2h_rep2.sam has been processed! # ../4.map-data/rna_700_2h_rep1.sam has been processed! # ... load_expression_data extract count and tpm matrix from files: # prepare matrix exp &lt;- load_expression_data() # Expression input files: # ribo_700_2h_r2h_rep1.exp.txt # ribo_700_2h_r2h_rep2.exp.txt # ribo_700_2h_rep1.exp.txt # ribo_700_2h_rep2.exp.txt # ribo_nromal_rep1.exp.txt # ribo_nromal_rep2.exp.txt # rna_700_2h_r2h_rep1.exp.txt # rna_700_2h_r2h_rep2.exp.txt # rna_700_2h_rep1.exp.txt # rna_700_2h_rep2.exp.txt # rna_nromal_rep1.exp.txt # rna_nromal_rep2.exp.txt head(exp$count_matrix[1:3,1:4]) # gene_name ribo_700_2h_r2h_rep1 ribo_700_2h_r2h_rep2 ribo_700_2h_rep1 # 1: 0610009B22Rik 126 124 39 # 2: 0610010F05Rik 81 70 5 # 3: 0610010K14Rik 65 64 2 head(exp$tpm_matrix[1:3,1:4]) # gene_name ribo_700_2h_r2h_rep1 ribo_700_2h_r2h_rep2 ribo_700_2h_rep1 # 1: 0610009B22Rik 51.687154 51.39426 70.832450 # 2: 0610010F05Rik 6.478891 5.65711 1.770685 # 3: 0610010K14Rik 19.544299 19.44319 2.662517 "],["selective-ribosome-profiling.html", "Chapter 5 Selective ribosome profiling", " Chapter 5 Selective ribosome profiling The selective ribosome profiling (SeRP) method is a new tool for studying the co-translational activity of maturation factors that provides proteome-wide information on a factor’s nascent interactome, the onset and duration of binding and the mechanisms controlling factor engagement. SeRP is based on the combination of two ribosome-profiling (RP) experiments, sequencing the ribosome-protected mRNA fragments from all ribosomes (total translatome) and the ribosome subpopulation engaged by the factor of interest (factor-bound translatome). For more details see Selective ribosome profiling to study interactions of translating ribosomes in yeast. Schematic overview of SeRP: Analysis of eukaryotic selective RP data: "],["serp-data-analysis.html", "Chapter 6 SeRP data analysis 6.1 Introduction 6.2 Extract yeast longest transcript sequence 6.3 Build index for tRNA, rRNA and reference 6.4 Trim adapters for raw fastqs 6.5 Remove tRNA and rRNA 6.6 Map to transcriptome 6.7 Ribo QC check 6.8 Calculate ribosome density 6.9 Enrichment analysis", " Chapter 6 SeRP data analysis 6.1 Introduction We show a entire example to analysis SeRP data which from Cotranslational assembly of protein complexes in eukaryotes revealed by ribosome profiling and the related GSE number is GSE116570. You can download the raw fastq files through other ways. Here shows the simple data processing describtion: 6.2 Extract yeast longest transcript sequence Condidering most transcripts have no UTRs(untranslated regions) of Saccharomyces cerevisiae.So we extend 50 bases upstream and downstream for each transcript. We choose to map the reads on transcriptome. Now we use BioSeqUtils to extract fasta: library(BioSeqUtils) library(RiboProfiler) # ============================================================================== # get longest transcript # ============================================================================== # make object mytest &lt;- loadGenomeGTF(gtfPath = &quot;Saccharomyces_cerevisiae.R64-1-1.105.gtf&quot;, genomePath = &quot;Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa&quot;, filterProtein = T) ## GenomeGTF object for Extracting sequences. ## GTF file is loaded. ## genome file is loaded. ## representTrans file is NULL. ## intron slot is NULL. # select all genes gene &lt;- unique(mytest@gtf$gene_name) # return all transcript info all &lt;- getTransInfo(object = mytest,geneName = gene,selecType = &quot;lcds&quot;,topN = 1) # extend sequence extend &lt;- getFeatureFromGenome(mytest,geneName = all$gene_name, type = &quot;exon&quot;, up.extend = 50, dn.extend = 50) # output Biostrings::writeXStringSet(extend,filepath = &quot;sac_longest_trans.fa&quot;,format = &quot;fasta&quot;) # check system(&quot;head sac_longest_trans.fa&quot;) # &gt;AAC1|YMR056C|YMR056C_mRNA|51|978|1030|CD # CAGATTCTCGTATCTGTTATTCTTTTCTATTTTTCCTTTTTACAGCAGTAATGTCTCACACAGAAACACAGACTCAGCAG # TCACACTTCGGTGTGGACTTCCTTATGGGCGGCGTTTCTGCTGCCATTGCGAAGACGGGTGCCGCTCCCATTGAACGGGT # GAAACTGTTGATGCAGAATCAAGAAGAGATGCTTAAACAGGGCTCGTTGGATACACGGTACAAGGGAATTTTAGATTGCT # TCAAGAGGACTGCGACTCATGAAGGTATTGTGTCGTTCTGGAGGGGTAACACCGCCAATGTTCTCCGGTATTTCCCCACG # CAGGCGCTGAATTTTGCCTTCAAAGACAAAATTAAGTCGTTGTTGAGTTACGACAGAGAGCGCGATGGGTATGCCAAGTG # GTTTGCTGGAAATCTTTTCTCTGGTGGAGCGGCTGGTGGTTTGTCGCTTCTATTTGTATATTCCTTGGACTACGCAAGGA # CGCGGCTTGCAGCGGATGCTAGGGGTTCTAAGTCAACCTCGCAAAGACAGTTTAATGGATTGCTAGACGTGTATAAGAAG # ACACTGAAAACGGACGGGTTGTTGGGTCTGTACCGTGGGTTTGTGCCCTCAGTTCTGGGTATCATTGTCTACAGAGGTCT # GTACTTTGGCTTGTACGATTCTTTCAAGCCTGTGCTGTTGACGGGGGCTCTAGAGGGGTCCTTTGTTGCCTCTTTCCTAT # [1] 0 6.3 Build index for tRNA, rRNA and reference # ============================================================================== # build index # ============================================================================== # download mouse rRNA and tRNA fetch_trRNA_from_NCBI(species = &quot;Saccharomyces cerevisiae&quot;) # ┌──────────────────────────────────────────────────────────────┐ # │ │ # │ Download tRNA and rRNA sequences from NCBI has finished! │ # │ │ # └──────────────────────────────────────────────────────────────┘ # build index trRNA_index_build(trRNA_file = &quot;Saccharomyces_cerevisiae_trRNA.fa&quot;, prefix = &quot;sac_trRNA&quot;) # ┌────────────────────────────────────────────────────┐ # │ │ # │ Building index for tRNA and rRNA has finished! │ # │ │ # └────────────────────────────────────────────────────┘ reference_index_build(reference_file = &quot;sac_longest_trans.fa&quot;, prefix = &quot;sac_ref&quot;, threads = 24) # ┌────────────────────────────────────────────────┐ # │ │ # │ Building index for reference has finished! │ # │ │ # └────────────────────────────────────────────────┘ 6.4 Trim adapters for raw fastqs # ============================================================================== # trim adaptors # ============================================================================== dir.create(&quot;2.trim-data&quot;) # raw fastq files fq &lt;- list.files(path = &quot;1.raw-data/&quot;,pattern = &quot;.gz$&quot;,full.names = T) rmd1 &lt;- batch_adpator_remove(fastq_file1 = fq, output_dir = &quot;2.trim-data/&quot;, output_name = sapply(strsplit(fq,split = &quot;\\\\.|/&quot;), &quot;[&quot;,3), fastp_params = list(minReadLength = 20, maxReadLength = 35, adapterSequenceRead1 = &quot;CTGTAGGCACCATCAATTCGTATGCCGTCTT&quot;, thread = 16)) 6.5 Remove tRNA and rRNA # ============================================================================== # remove trRNA sequence # ============================================================================== dir.create(&quot;3.rmtrRNA-data&quot;) # loop for remove trRNA sequence clean_fq &lt;- list.files(&quot;2.trim-data/&quot;,pattern = &quot;.fastq.gz&quot;,full.names = T) output_sam &lt;- paste(&quot;3.rmtrRNA-data/&quot;,sapply(strsplit(clean_fq,split = &quot;_R1.fastq.gz|/&quot;), &quot;[&quot;,2), &quot;.sam&quot;,sep = &quot;&quot;) rm_trRNAfq &lt;- paste(&quot;3.rmtrRNA-data/&quot;,sapply(strsplit(clean_fq,split = &quot;_R1.fastq.gz|/&quot;), &quot;[&quot;,2), &quot;_rmtrRNA.fq&quot;,sep = &quot;&quot;) # x = 1 # batch align lapply(seq_along(clean_fq),function(x){ bowtie2_align(index = &quot;0.index-data/rtRNA-index/sac_trRNA&quot;, fq_file1 = clean_fq[x], output_file = output_sam[x], threads = 24, bowtie2_params = paste(&quot;--un &quot;,rm_trRNAfq[x],sep = &quot;&quot;)) }) -&gt; tmp # ▶ 3.rmtrRNA-data/SRR7471227.sam has been processed! # ▶ 3.rmtrRNA-data/SRR7471228.sam has been processed! # ▶ 3.rmtrRNA-data/SRR7471229.sam has been processed! # ... # remove tmp sam file.remove(list.files(&quot;3.rmtrRNA-data/&quot;,pattern = &quot;.sam$&quot;,full.names = T)) # plot mapping info map_info &lt;- list.files(&quot;3.rmtrRNA-data/&quot;,pattern = &quot;mapinfo.txt&quot;,full.names = TRUE) plot_mapinfo(mapinfo_file = map_info, file_name = sapply(strsplit(clean_fq,split = &quot;\\\\.|/|_R1&quot;), &quot;[&quot;,3)) # plot_mapinfo(mapinfo_file = map_info, # file_name = sapply(strsplit(clean_fq,split = &quot;\\\\.|/|_R1&quot;), &quot;[&quot;,3), # plot_type = &quot;table&quot;) 6.6 Map to transcriptome # ============================================================================== # map to transcriptome # ============================================================================== dir.create(&quot;4.map-data&quot;) # batch map to genome fq_file1 &lt;- list.files(&quot;3.rmtrRNA-data/&quot;,pattern = &quot;.fq&quot;,full.names = T) output_file &lt;- c(&#39;FAS1-trans-rep1&#39;,&#39;FAS1-inter-rep1&#39;,&#39;FAS1-trans-rep2&#39;,&#39;FAS1-inter-rep2&#39;, &#39;FAS2-trans-rep1&#39;,&#39;FAS2-inter-rep1&#39;,&#39;FAS2-trans-rep2&#39;,&#39;FAS2-inter-rep2&#39;, &#39;FAS1-MPTdel-trans-rep1&#39;,&#39;FAS1-MPTdel-inter-rep1&#39;,&#39;FAS1-MPTdel-trans-rep2&#39;, &#39;FAS1-MPTdel-trans-rep3&#39;,&#39;FAS1-MPTdel-inter-rep2&#39;,&#39;FAS1-MPTdel-inter-rep3&#39;, &#39;FAS2-MPTdel-trans-rep1&#39;,&#39;FAS2-MPTdel-inter-rep1&#39;,&#39;FAS2-MPTdel-trans-rep2&#39;,&#39;FAS2-MPTdel-inter-rep2&#39;, &#39;GUS1-trans-rep1&#39;,&#39;GUS1-inter-rep1&#39;,&#39;GUS1-trans-rep2&#39;,&#39;GUS1-inter-rep2&#39;, &#39;MES1-trans-rep1&#39;,&#39;MES1-inter-rep1&#39;,&#39;MES1-trans-rep2&#39;,&#39;MES1-inter-rep2&#39;, &#39;ARC1-trans-rep1&#39;,&#39;ARC1-inter-rep1&#39;,&#39;ARC1-trans-rep2&#39;,&#39;ARC1-inter-rep2&#39;) batch_hisat_align(index = &quot;0.index-data/ref-index/sac_ref&quot;, fq_file1 = fq_file1, output_dir = &quot;4.map-data/&quot;, output_file = output_file, threads = 24,hisat2_params = list(k = 1)) # ▶ FAS1-trans-rep1 has been processed! # ▶ FAS1-inter-rep1 has been processed! # ▶ FAS1-trans-rep2 has been processed! # ... # plot mapping info map_info_geome &lt;- list.files(&quot;4.map-data/&quot;,pattern = &quot;mapinfo.txt&quot;,full.names = TRUE) plot_mapinfo(mapinfo_file = map_info_geome, file_name = sapply(strsplit(map_info_geome,split = &quot;_mapinfo.txt|/&quot;), &quot;[&quot;,2)) # plot_mapinfo(mapinfo_file = map_info_geome, # file_name = sapply(strsplit(map_info_geome,split = &quot;_mapinfo.txt|/&quot;), &quot;[&quot;,2), # plot_type = &quot;table&quot;) 6.7 Ribo QC check The similar analysis steps like before: dir.create(&quot;5.analysis-data&quot;) setwd(&quot;5.analysis-data&quot;) # ============================================================================== # 1_prepare gene annotation file # ============================================================================== # ... # ============================================================================== # 2_prepare Ribo QC data # ============================================================================== sam_file = list.files(&quot;../4.map-data/&quot;,pattern = &quot;*sam$&quot;,full.names = TRUE) sample_name &lt;- sapply(strsplit(list.files(&quot;../4.map-data/&quot;,pattern = &quot;*sam$&quot;), split = &quot;.sam&quot;), &quot;[&quot;,1) # run pre_qc_data(sam_file = sam_file, out_file = paste(sample_name,&quot;.qc.txt&quot;,sep = &quot;&quot;), mapping_type = &quot;transcriptome&quot;, seq_type = &quot;singleEnd&quot;) # ../4.map-data/ARC1-inter-rep1.sam has been processed! # ../4.map-data/ARC1-inter-rep2.sam has been processed! # ../4.map-data/ARC1-trans-rep1.sam has been processed! # ... # load qc data qc_df &lt;- load_qc_data() qc_df &lt;- qc_df |&gt; dplyr::filter(length &gt;= 20 &amp; length &lt;= 35) # check head(qc_df,3) # length framest relst framesp relsp feature counts sample group # 1 29 1 826 0 -1689 3 1 ARC1-inter-rep1 NA # 2 24 1 151 0 -306 3 4 ARC1-inter-rep1 NA # 3 26 1 3118 0 -714 3 1 ARC1-inter-rep1 NA qc_df$length &lt;- factor(qc_df$length) qc_df$sample &lt;- factor(qc_df$sample, levels = c(&#39;FAS1-trans-rep1&#39;,&#39;FAS1-trans-rep2&#39;, &#39;FAS2-trans-rep1&#39;,&#39;FAS2-trans-rep2&#39;, &#39;FAS1-MPTdel-trans-rep1&#39;,&#39;FAS1-MPTdel-trans-rep2&#39;,&#39;FAS1-MPTdel-trans-rep3&#39;, &#39;FAS2-MPTdel-trans-rep1&#39;,&#39;FAS2-MPTdel-trans-rep2&#39;, &#39;GUS1-trans-rep1&#39;,&#39;GUS1-trans-rep2&#39;, &#39;MES1-trans-rep1&#39;,&#39;MES1-trans-rep2&#39;, &#39;ARC1-trans-rep1&#39;,&#39;ARC1-trans-rep2&#39;, &#39;FAS1-inter-rep1&#39;,&#39;FAS1-inter-rep2&#39;, &#39;FAS2-inter-rep1&#39;,&#39;FAS2-inter-rep2&#39;, &#39;FAS1-MPTdel-inter-rep1&#39;,&#39;FAS1-MPTdel-inter-rep2&#39;,&#39;FAS1-MPTdel-inter-rep3&#39;, &#39;FAS2-MPTdel-inter-rep1&#39;,&#39;FAS2-MPTdel-inter-rep2&#39;, &#39;GUS1-inter-rep1&#39;,&#39;GUS1-inter-rep2&#39;, &#39;MES1-inter-rep1&#39;,&#39;MES1-inter-rep2&#39;, &#39;ARC1-inter-rep1&#39;,&#39;ARC1-inter-rep2&#39;)) Length distribution: # length distribution qc_plot(qc_data = qc_df,type = &quot;length&quot;,facet_wrap_list = list(ncol = 5)) Frames with length distribution: # length with frame qc_plot(qc_data = qc_df,type = &quot;length_frame&quot;,facet_wrap_list = list(ncol = 5)) Different region features: # region features qc_plot(qc_data = qc_df,type = &quot;feature&quot;,facet_wrap_list = list(ncol = 5)) All frames ratio: # all frames qc_plot(qc_data = qc_df,type = &quot;frame&quot;,facet_wrap_list = list(ncol = 5)) Realtive to start codon with periodicity: # relative to start/stop site 5x9 rel_to_start_stop(qc_data = qc_df,type = &quot;relst&quot;, facet_wrap_list = list(ncol = 5)) # rel_to_start_stop(qc_data = qc_df,type = &quot;relsp&quot;, # facet_wrap_list = list(ncol = 5,scales = &quot;fixed&quot;)) 6.8 Calculate ribosome density # calculate Ribo density pre_ribo_density_data(sam_file = sam_file, out_file = paste(sample_name,&quot;.density.txt&quot;,sep = &quot;&quot;), mapping_type = &quot;transcriptome&quot;) # ../4.map-data/ARC1-inter-rep1.sam has been processed! # ../4.map-data/ARC1-inter-rep2.sam has been processed! # ../4.map-data/ARC1-trans-rep1.sam has been processed! # ... 6.9 Enrichment analysis 6.9.1 calculate enrichment ratio This step calculate the density ratio of factor-bound translatome and total translatome. pre_enrichment_data will calculate enrichment for each transcript positions: setwd(&quot;5.analysis-data&quot;) total &lt;- paste(&quot;2.density-data/&quot;, c(&#39;FAS1-trans-rep1&#39;,&#39;FAS1-trans-rep2&#39;, &#39;FAS2-trans-rep1&#39;,&#39;FAS2-trans-rep2&#39;, &#39;FAS1-MPTdel-trans-rep1&#39;,&#39;FAS1-MPTdel-trans-rep2&#39;,&#39;FAS1-MPTdel-trans-rep3&#39;, &#39;FAS2-MPTdel-trans-rep1&#39;,&#39;FAS2-MPTdel-trans-rep2&#39;, &#39;GUS1-trans-rep1&#39;,&#39;GUS1-trans-rep2&#39;, &#39;MES1-trans-rep1&#39;,&#39;MES1-trans-rep2&#39;, &#39;ARC1-trans-rep1&#39;,&#39;ARC1-trans-rep2&#39;), &quot;.density.txt&quot;,sep = &quot;&quot;) ip &lt;- paste(&quot;2.density-data/&quot;, c(&#39;FAS1-inter-rep1&#39;,&#39;FAS1-inter-rep2&#39;, &#39;FAS2-inter-rep1&#39;,&#39;FAS2-inter-rep2&#39;, &#39;FAS1-MPTdel-inter-rep1&#39;,&#39;FAS1-MPTdel-inter-rep2&#39;,&#39;FAS1-MPTdel-inter-rep3&#39;, &#39;FAS2-MPTdel-inter-rep1&#39;,&#39;FAS2-MPTdel-inter-rep2&#39;, &#39;GUS1-inter-rep1&#39;,&#39;GUS1-inter-rep2&#39;, &#39;MES1-inter-rep1&#39;,&#39;MES1-inter-rep2&#39;, &#39;ARC1-inter-rep1&#39;,&#39;ARC1-inter-rep2&#39;), &quot;.density.txt&quot;,sep = &quot;&quot;) # calculate enrich ratio dir.create(&quot;3.enrich-data&quot;) # output out_file &lt;- paste(&quot;3.enrich-data/&quot;, c(&quot;FAS1-rep1&quot;,&quot;FAS1-rep2&quot;,&quot;FAS2-rep1&quot;,&quot;FAS2-rep2&quot;, &quot;FAS1-MPTdel-rep1&quot;,&quot;FAS1-MPTdel-rep2&quot;,&quot;FAS1-MPTdel-rep3&quot;, &quot;FAS2-MPTdel-rep1&quot;,&quot;FAS2-MPTdel-rep2&quot;, &quot;GUS1-rep1&quot;,&quot;GUS1-rep2&quot;,&quot;MES1-rep1&quot;,&quot;MES1-rep2&quot;,&quot;ARC1-rep1&quot;,&quot;ARC1-rep2&quot;), &quot;.enrich.txt&quot;,sep = &quot;&quot;) # run pre_enrichment_data(riboIP_file = ip, riboInput_file = total, output_file = out_file) # 3.enrich-data/FAS1-rep1.enrich.txt has been processed! # 3.enrich-data/FAS1-rep2.enrich.txt has been processed! # 3.enrich-data/FAS2-rep1.enrich.txt has been processed! # ... 6.9.2 track plot First we show the raw seRP figure from paper: You can still use track_plot to visualize the output: # ============================================================================== # load data and visualize # ============================================================================== df_fasx &lt;- load_enrich_data(enrich_data = c(&quot;3.enrich-data/ARC1-rep1.enrich.txt&quot;, &quot;3.enrich-data/ARC1-rep2.enrich.txt&quot;, &quot;3.enrich-data/GUS1-rep1.enrich.txt&quot;, &quot;3.enrich-data/GUS1-rep2.enrich.txt&quot;, &quot;3.enrich-data/MES1-rep1.enrich.txt&quot;, &quot;3.enrich-data/MES1-rep2.enrich.txt&quot;), gene_names = c(&#39;ARC1&#39;,&#39;GUS1&#39;,&#39;MES1&#39;), sample_name = c(&quot;ARC1&quot;,&quot;ARC1&quot;,&quot;GUS1&quot;,&quot;GUS1&quot;,&quot;MES1&quot;,&quot;MES1&quot;)) # check head(df_fasx,3) # # A tibble: 3 × 7 # # Groups: gene_name, trans_id, codon_pos, type [1] # gene_name trans_id codon_pos type sample density density_sd # &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 ARC1 YGL105W_mRNA 1 ribo ARC1 0.690 0.976 # 2 ARC1 YGL105W_mRNA 1 ribo GUS1 0.796 0.0103 # 3 ARC1 YGL105W_mRNA 1 ribo MES1 0.868 0.888 # plot 6x10 track_plot(plot_type = &quot;interactome&quot;, signal_data = df_fasx, gene_order = c(&#39;GUS1&#39;,&#39;ARC1&#39;,&#39;MES1&#39;), sample_order = c(&#39;GUS1&#39;,&#39;MES1&#39;,&#39;ARC1&#39;), line_col = c(&#39;GUS1&#39; = &#39;#4883C6&#39;,&#39;ARC1&#39; = &#39;#AA356A&#39;,&#39;MES1&#39; = &#39;#D52C30&#39;), remove_trans_panel_border = T) 6.9.3 enrichment with slide window In the article, author used a slide window with 20nt to smooth the enrichment density: You can also do this with pre_slideWindow_enrichment_data function. # calculate enrich ratio dir.create(&quot;4.swEnrich-data&quot;) total &lt;- paste(&quot;2.density-data/&quot;, c(&#39;GUS1-trans-rep1&#39;,&#39;GUS1-trans-rep2&#39;, &#39;MES1-trans-rep1&#39;,&#39;MES1-trans-rep2&#39;, &#39;ARC1-trans-rep1&#39;,&#39;ARC1-trans-rep2&#39;), &quot;.density.txt&quot;,sep = &quot;&quot;) ip &lt;- paste(&quot;2.density-data/&quot;, c(&#39;GUS1-inter-rep1&#39;,&#39;GUS1-inter-rep2&#39;, &#39;MES1-inter-rep1&#39;,&#39;MES1-inter-rep2&#39;, &#39;ARC1-inter-rep1&#39;,&#39;ARC1-inter-rep2&#39;), &quot;.density.txt&quot;,sep = &quot;&quot;) # output out_file &lt;- paste(&quot;4.swEnrich-data/&quot;, c(&quot;GUS1-rep1&quot;,&quot;GUS1-rep2&quot;,&quot;MES1-rep1&quot;,&quot;MES1-rep2&quot;,&quot;ARC1-rep1&quot;,&quot;ARC1-rep2&quot;), &quot;.enrich.txt&quot;,sep = &quot;&quot;) # run pre_slideWindow_enrichment_data(riboIP_file = ip, riboInput_file = total, gene_list = c(&#39;GUS1&#39;,&#39;ARC1&#39;,&#39;MES1&#39;), output_file = out_file) Visualize data: # ============================================================================== # load data and visualize # ============================================================================== file &lt;- list.files(&quot;4.swEnrich-data/&quot;,&quot;*.txt&quot;,full.names = T) file # [1] &quot;4.swEnrich-data/ARC1-rep1.enrich.txt&quot; &quot;4.swEnrich-data/ARC1-rep2.enrich.txt&quot; # [3] &quot;4.swEnrich-data/GUS1-rep1.enrich.txt&quot; &quot;4.swEnrich-data/GUS1-rep2.enrich.txt&quot; # [5] &quot;4.swEnrich-data/MES1-rep1.enrich.txt&quot; &quot;4.swEnrich-data/MES1-rep2.enrich.txt&quot; df_sw &lt;- load_enrich_data(data_type = &quot;sw&quot;, enrich_data = file, sample_name = c(&quot;ARC1&quot;,&quot;ARC1&quot;,&quot;GUS1&quot;,&quot;GUS1&quot;,&quot;MES1&quot;,&quot;MES1&quot;)) # check head(df_sw[1:3,]) # # A tibble: 3 × 7 # # Groups: gene_name, trans_id, codon_pos, type [1] # gene_name trans_id codon_pos type sample density density_sd # &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 ARC1 YGL105W_mRNA 1 ribo ARC1 1.82 0.152 # 2 ARC1 YGL105W_mRNA 1 ribo GUS1 1.49 0.0293 # 3 ARC1 YGL105W_mRNA 1 ribo MES1 2.09 1.33 # plot 6x10 track_plot(plot_type = &quot;interactome&quot;, signal_data = df_sw, gene_order = c(&#39;GUS1&#39;,&#39;ARC1&#39;,&#39;MES1&#39;), sample_order = c(&#39;GUS1&#39;,&#39;MES1&#39;,&#39;ARC1&#39;), line_col = c(&#39;GUS1&#39; = &#39;#4883C6&#39;,&#39;ARC1&#39; = &#39;#AA356A&#39;,&#39;MES1&#39; = &#39;#D52C30&#39;), remove_trans_panel_border = T) This looks much better! "],["running-on-linux.html", "Chapter 7 Running on linux 7.1 Introduction 7.2 Prepare conda environment 7.3 Qc for fastq files 7.4 Trim adapters 7.5 Remove tRNA and rRNA contamination 7.6 Align reads on genome", " Chapter 7 Running on linux 7.1 Introduction Some bioinformatics software may require frequent updates, and the corresponding R packages may not be updated in a timely manner or may not be maintained by anyone at all. Therefore, it is best to use relatively new software for upstream data analysis. One issue is that switching between Linux systems and RStudio can become inconvenient. If you are using RStudio on a server or Linux system, a good approach is to use the R functions system or system2 to call software within the Linux system. This allows us to perform upstream data analysis directly within RStudio. Conda is an open-source package management system and environment management system that helps you to install and manage software packages and dependencies in various programming languages, including Python, R, Ruby, Lua, Java, and others. Conda allows you to create isolated environments for different projects with their own set of packages and dependencies, so that each project can have its own environment without interfering with other projects. Conda also provides a central repository of pre-built packages called “conda-forge”, where users can find and install packages easily. With conda, you can easily install, update, and remove packages and dependencies with a simple command-line interface or through graphical interfaces like Anaconda Navigator or Miniconda. So we can call softwares which are installed in conda environment and use in Rstudio directly. The following chapter we describe how do this in Rstudio and do the Ribo-seq upstream data analysis. 7.2 Prepare conda environment First you need install Miniconda: $ wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py39_23.3.1-0-Linux-x86_64.sh $ bash Miniconda3-py39_23.3.1-0-Linux-x86_64.sh Add some channels for conda: $ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ $ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ $ conda config --add channels bioconda Then create and activate your environment: $ conda create -n rnaseq $ conda activate rnaseq Last install softwares in this environment what you like: $ conda install fastqc bowtie2 hisat2 samtools adapterremoval 7.3 Qc for fastq files We call fastqc in conda rnaseq environment and check raw fastq files. call_cmd function allow you to give quoted command and excute them: # ============================================================================== # fastqc for fastq # ============================================================================== dir.create(&quot;2.fastqc-data&quot;) fastqc &lt;- &quot;/root/miniconda3/envs/rnaseq/bin/fastqc&quot; call_cmd(fastqc,&quot;-h&quot;) # FastQC - A high throughput sequence QC analysis tool # # SYNOPSIS # # fastqc seqfile1 seqfile2 .. seqfileN # # fastqc [-o output dir] [--(no)extract] [-f fastq|bam|sam] # [-c contaminant file] seqfile1 .. seqfileN # ... fastq &lt;- list.files(&quot;../1.mapping_to_genome/1.raw-data/&quot;,&quot;*.gz&quot;,full.names = T)[1:2] fastq # [1] &quot;../1.mapping_to_genome/1.raw-data//SRR12594201.fastq.gz&quot; # [2] &quot;../1.mapping_to_genome/1.raw-data//SRR12594205.fastq.gz&quot; # get absolute path fq_path &lt;- normalizePath(fastq) fq_path # [1] &quot;/mnt/f/reanalysis_from_papers/7.ribo-package-test/1.mapping_to_genome/1.raw-data/SRR12594201.fastq.gz&quot; # [2] &quot;/mnt/f/reanalysis_from_papers/7.ribo-package-test/1.mapping_to_genome/1.raw-data/SRR12594205.fastq.gz&quot; # run qc call_cmd(fastqc,&quot;-t 12&quot;,&quot;-q&quot;,&quot;-o 2.fastqc-data/&quot;,fq_path) # application/gzip # application/gzip # check files list.files(&quot;2.fastqc-data&quot;) # [1] &quot;SRR12594201_fastqc.html&quot; &quot;SRR12594201_fastqc.zip&quot; &quot;SRR12594205_fastqc.html&quot; &quot;SRR12594205_fastqc.zip&quot; 7.4 Trim adapters Rmove adapters using AdapterRemoval: # ============================================================================== # trim adapters # ============================================================================== dir.create(&quot;3.trim-data&quot;) AdapterRemoval &lt;- &quot;/root/miniconda3/envs/rnaseq/bin/AdapterRemoval&quot; call_cmd(AdapterRemoval,&quot;-h&quot;) # AdapterRemoval ver. 2.3.3 # # This program searches for and removes remnant adapter sequences from # your read data. The program can analyze both single end and paired end # data. For detailed explanation of the parameters, please refer to the # man page. For comments, suggestions and feedback please contact Stinus # Lindgreen (stinus@binf.ku.dk) and Mikkel Schubert (MikkelSch@gmail.com). # # If you use the program, please cite the paper: # Schubert, Lindgreen, and Orlando (2016). AdapterRemoval v2: rapid # adapter trimming, identification, and read merging. # BMC Research Notes, 12;9(1):88. # # http://bmcresnotes.biomedcentral.com/articles/10.1186/s13104-016-1900-2 # ... # run trim # x = 1 output_name &lt;- paste(&quot;3.trim-data/&quot;,c(&quot;test1&quot;,&quot;test2&quot;),sep = &quot;&quot;) lapply(1:2, function(x){ call_cmd(AdapterRemoval,&quot;--threads 12&quot;, &quot;--adapter1 CTGTAGGCACCATCAAT&quot;, &quot;--trim5p 6&quot;,&quot;--trim3p 4&quot;,&quot;--minlength 15&quot;, paste(&quot;--file1&quot;,fq_path[x]), &quot;--gzip&quot;, paste(&quot;--basename&quot;,output_name[x])) }) -&gt; tmp # Trimming single ended reads ... # Opening FASTQ file &#39;/mnt/f/reanalysis_from_papers/7.ribo-package-test/1.mapping_to_genome/1.raw-data/SRR12594201.fastq.gz&#39;, line numbers start at 1 # Processed a total of 27,170,397 reads in 3:07.2s; 145,000 reads per second on average ... # Trimming single ended reads ... # Opening FASTQ file &#39;/mnt/f/reanalysis_from_papers/7.ribo-package-test/1.mapping_to_genome/1.raw-data/SRR12594205.fastq.gz&#39;, line numbers start at 1 # Processed a total of 26,741,698 reads in 2:27.8s; 180,000 reads per second on average ... # check clean fastqs list.files(&quot;3.trim-data/&quot;) # [1] &quot;test1.discarded.gz&quot; &quot;test1.settings&quot; &quot;test1.truncated.gz&quot; # [4] &quot;test2.discarded.gz&quot; &quot;test2.settings&quot; &quot;test2.truncated.gz&quot; 7.5 Remove tRNA and rRNA contamination We use bowtie2 to align reads on trRNA index: # ============================================================================== # remove rRNA and tRNA contamination # ============================================================================== dir.create(&quot;4.rmtrRNA-data&quot;) bowtie2 &lt;- &quot;/root/miniconda3/envs/rnaseq/bin/bowtie2&quot; call_cmd(bowtie2,&quot;-h&quot;) # Bowtie 2 version 2.5.1 by Ben Langmead (langmea@cs.jhu.edu, www.cs.jhu.edu/~langmea) # Usage: # bowtie2 [options]* -x &lt;bt2-idx&gt; {-1 &lt;m1&gt; -2 &lt;m2&gt; | -U &lt;r&gt; | --interleaved &lt;i&gt; | -b &lt;bam&gt;} [-S &lt;sam&gt;] # # &lt;bt2-idx&gt; Index filename prefix (minus trailing .X.bt2). # NOTE: Bowtie 1 and Bowtie 2 indexes are not compatible. # &lt;m1&gt; Files with #1 mates, paired with files in &lt;m2&gt;. # Could be gzip&#39;ed (extension: .gz) or bzip2&#39;ed (extension: .bz2). # &lt;m2&gt; Files with #2 mates, paired with files in &lt;m1&gt;. # Could be gzip&#39;ed (extension: .gz) or bzip2&#39;ed (extension: .bz2). # ... # run mapping clean_fq &lt;- list.files(&quot;3.trim-data/&quot;,&quot;*.truncated.gz&quot;,full.names = T) output_name &lt;- paste(&quot;4.rmtrRNA-data/&quot;,c(&quot;test1_rmtrRNA.fq.gz&quot;,&quot;test2_rmtrRNA.fq.gz&quot;),sep = &quot;&quot;) lapply(1:2, function(x){ call_cmd(bowtie2, &quot;-x ../1.mapping_to_genome/0.index-data/rtRNA-index/GRCm38_trRNA&quot;, &quot;--threads 12&quot;, paste(&quot;--un-gz&quot;,output_name[x]), paste(&quot;-U&quot;,clean_fq[x]), paste(&quot;-S &quot;,output_name[x],&quot;.sam&quot;,sep = &quot;&quot;)) # remove tmp files file.remove(list.files(&quot;4.rmtrRNA-data/&quot;,&quot;*.sam&quot;,full.names = T)) }) -&gt; tmp # 27154794 reads; of these: # 27154794 (100.00%) were unpaired; of these: # 11156550 (41.09%) aligned 0 times # 277586 (1.02%) aligned exactly 1 time # 15720658 (57.89%) aligned &gt;1 times # 58.91% overall alignment rate # 26706601 reads; of these: # 26706601 (100.00%) were unpaired; of these: # 4396448 (16.46%) aligned 0 times # 171860 (0.64%) aligned exactly 1 time # 22138293 (82.89%) aligned &gt;1 times # 83.54% overall alignment rate # check files list.files(&quot;4.rmtrRNA-data/&quot;,&quot;*.gz&quot;) # [1] &quot;test1_rmtrRNA.fq.gz&quot; &quot;test2_rmtrRNA.fq.gz&quot; 7.6 Align reads on genome We use hisat2 align the clean reads on genome: # ============================================================================== # mapping on genome # ============================================================================== dir.create(&quot;5.map-data&quot;) hisat2 &lt;- &quot;/root/miniconda3/envs/rnaseq/bin/hisat2&quot; samtools &lt;- &quot;/root/miniconda3/envs/rnaseq/bin/samtools&quot; call_cmd(hisat2,&quot;-h&quot;) # HISAT2 version 2.2.1 by Daehwan Kim (infphilo@gmail.com, www.ccb.jhu.edu/people/infphilo) # Usage: # hisat2 [options]* -x &lt;ht2-idx&gt; {-1 &lt;m1&gt; -2 &lt;m2&gt; | -U &lt;r&gt;} [-S &lt;sam&gt;] # # &lt;ht2-idx&gt; Index filename prefix (minus trailing .X.ht2). # &lt;m1&gt; Files with #1 mates, paired with files in &lt;m2&gt;. # Could be gzip&#39;ed (extension: .gz) or bzip2&#39;ed (extension: .bz2). # &lt;m2&gt; Files with #2 mates, paired with files in &lt;m1&gt;. # Could be gzip&#39;ed (extension: .gz) or bzip2&#39;ed (extension: .bz2). # ... # run mapping clean_fq &lt;- list.files(&quot;4.rmtrRNA-data/&quot;,&quot;*.gz&quot;,full.names = T) output_name &lt;- paste(&quot;5.map-data/&quot;,c(&quot;test1.bam&quot;,&quot;test2.bam&quot;),sep = &quot;&quot;) lapply(1:2, function(x){ call_cmd(hisat2, &quot;-x ../1.mapping_to_genome/0.index-data/ref-index/GRCm38_ref&quot;, &quot;--threads 12&quot;, paste(&quot;-U&quot;,clean_fq[x]), paste(&quot;|&quot;,samtools,&quot;sort&quot;,&quot;-@ 6 -o&quot;,output_name[x])) }) -&gt; tmp # 11156550 reads; of these: # 11156550 (100.00%) were unpaired; of these: # 3307706 (29.65%) aligned 0 times # 5063068 (45.38%) aligned exactly 1 time # 2785776 (24.97%) aligned &gt;1 times # 70.35% overall alignment rate # [bam_sort_core] merging from 0 files and 6 in-memory blocks... # 4396448 reads; of these: # 4396448 (100.00%) were unpaired; of these: # 1699590 (38.66%) aligned 0 times # 1140442 (25.94%) aligned exactly 1 time # 1556416 (35.40%) aligned &gt;1 times # 61.34% overall alignment rate # [bam_sort_core] merging from 0 files and 6 in-memory blocks... Make index for bam files: # index for bam call_cmd(&quot;ls&quot;,&quot;5.map-data/*.bam&quot;,&quot;| xargs -i&quot;,samtools,&quot;index -@ 12 {}&quot;) # check files list.files(&quot;5.map-data/&quot;,&quot;*&quot;) # [1] &quot;test1.bam&quot; &quot;test1.bam.bai&quot; &quot;test2.bam&quot; &quot;test2.bam.bai&quot; As you see, you can call linux softwares easily in Rstudio and do not need to turn into linux system and write command line. This is great. Just try it now and see what you can do. "],["track_plot-supplement.html", "Chapter 8 Track_plot supplement", " Chapter 8 Track_plot supplement Here show some examples for track_plot function. A simple plot: track_plot(plot_type = &quot;interactome&quot;, signal_data = df_sw, gene_order = c(&#39;GUS1&#39;,&#39;ARC1&#39;,&#39;MES1&#39;), sample_order = c(&#39;GUS1&#39;,&#39;MES1&#39;,&#39;ARC1&#39;), line_col = c(&#39;GUS1&#39; = &#39;#4883C6&#39;,&#39;ARC1&#39; = &#39;#AA356A&#39;,&#39;MES1&#39; = &#39;#D52C30&#39;)) Remove trans panel border: track_plot(plot_type = &quot;interactome&quot;, signal_data = df_sw, gene_order = c(&#39;GUS1&#39;,&#39;ARC1&#39;,&#39;MES1&#39;), sample_order = c(&#39;GUS1&#39;,&#39;MES1&#39;,&#39;ARC1&#39;), line_col = c(&#39;GUS1&#39; = &#39;#4883C6&#39;,&#39;ARC1&#39; = &#39;#AA356A&#39;,&#39;MES1&#39; = &#39;#D52C30&#39;), remove_trans_panel_border = T) You can also remove all panel borders: track_plot(plot_type = &quot;interactome&quot;, signal_data = df_sw, gene_order = c(&#39;GUS1&#39;,&#39;ARC1&#39;,&#39;MES1&#39;), sample_order = c(&#39;GUS1&#39;,&#39;MES1&#39;,&#39;ARC1&#39;), line_col = c(&#39;GUS1&#39; = &#39;#4883C6&#39;,&#39;ARC1&#39; = &#39;#AA356A&#39;,&#39;MES1&#39; = &#39;#D52C30&#39;), remove_all_panel_border = T) Show y axis ticks instead of text range: track_plot(plot_type = &quot;interactome&quot;, signal_data = df_sw, gene_order = c(&#39;GUS1&#39;,&#39;ARC1&#39;,&#39;MES1&#39;), sample_order = c(&#39;GUS1&#39;,&#39;MES1&#39;,&#39;ARC1&#39;), line_col = c(&#39;GUS1&#39; = &#39;#4883C6&#39;,&#39;ARC1&#39; = &#39;#AA356A&#39;,&#39;MES1&#39; = &#39;#D52C30&#39;), remove_trans_panel_border = T, show_y_ticks = T) Modify details for multiple graph layers: track_plot(plot_type = &quot;interactome&quot;, signal_data = df_sw, gene_order = c(&#39;GUS1&#39;,&#39;ARC1&#39;,&#39;MES1&#39;), sample_order = c(&#39;GUS1&#39;,&#39;MES1&#39;,&#39;ARC1&#39;), line_col = c(&#39;GUS1&#39; = &#39;#4883C6&#39;,&#39;ARC1&#39; = &#39;#AA356A&#39;,&#39;MES1&#39; = &#39;#D52C30&#39;), remove_trans_panel_border = T, geom_line_params = list(size = 1), geom_hline_params = list(yintercept = 5,color = &quot;black&quot;), geom_ribbon_params = list(alpha = 0.6)) Turn off fixed y axis range by column: track_plot(plot_type = &quot;interactome&quot;, signal_data = df_sw, gene_order = c(&#39;GUS1&#39;,&#39;ARC1&#39;,&#39;MES1&#39;), sample_order = c(&#39;GUS1&#39;,&#39;MES1&#39;,&#39;ARC1&#39;), line_col = c(&#39;GUS1&#39; = &#39;#4883C6&#39;,&#39;ARC1&#39; = &#39;#AA356A&#39;,&#39;MES1&#39; = &#39;#D52C30&#39;), remove_trans_panel_border = T, show_y_ticks = T, fixed_col_range = F) Show x axis: track_plot(plot_type = &quot;interactome&quot;, signal_data = df_sw, gene_order = c(&#39;GUS1&#39;,&#39;ARC1&#39;,&#39;MES1&#39;), sample_order = c(&#39;GUS1&#39;,&#39;MES1&#39;,&#39;ARC1&#39;), line_col = c(&#39;GUS1&#39; = &#39;#4883C6&#39;,&#39;ARC1&#39; = &#39;#AA356A&#39;,&#39;MES1&#39; = &#39;#D52C30&#39;), show_x_ticks = T) Remove gene structure panel: track_plot(plot_type = &quot;interactome&quot;, signal_data = df_sw, gene_order = c(&#39;GUS1&#39;,&#39;ARC1&#39;,&#39;MES1&#39;), sample_order = c(&#39;GUS1&#39;,&#39;MES1&#39;,&#39;ARC1&#39;), line_col = c(&#39;GUS1&#39; = &#39;#4883C6&#39;,&#39;ARC1&#39; = &#39;#AA356A&#39;,&#39;MES1&#39; = &#39;#D52C30&#39;), show_x_ticks = T, add_gene_struc = F) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
